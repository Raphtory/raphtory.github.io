{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Raphtory","text":"<p> \ud83c\udf0d Website  \ud83d\udcd2 API Documentation  Pometry \ud83e\uddd9\ud83c\udffb\u200d Tutorial \ud83d\udc1b Report a Bug  Join Slack </p> <p></p> <p>Raphtory is an in-memory graph tool written in Rust with friendly Python APIs on top. It is blazingly fast, scales to hundreds of millions of edges  on your laptop, and can be dropped into your existing pipelines with a simple <code>pip install raphtory</code>.  </p> <p>It supports time traveling, multilayer modelling, and advanced analytics beyond simple querying like community evolution, dynamic scoring, and mining temporal motifs.</p> <p>Below you can see an example of these APIs and the sort of questions you can ask!</p>  Python <p> <code>Graph</code> <pre><code>from raphtory import Graph\nfrom raphtory import algorithms as algo\nimport pandas as pd\n\n# Create a new graph\ngraph = Graph()\n\n# Add some data to your graph\ngraph.add_node(timestamp=1, id=\"Alice\")\ngraph.add_node(timestamp=1, id=\"Bob\")\ngraph.add_node(timestamp=1, id=\"Charlie\")\ngraph.add_edge(timestamp=2, src=\"Bob\", dst=\"Charlie\", properties={\"weight\": 5.0})\ngraph.add_edge(timestamp=3, src=\"Alice\", dst=\"Bob\", properties={\"weight\": 10.0})\ngraph.add_edge(timestamp=3, src=\"Bob\", dst=\"Charlie\", properties={\"weight\": -15.0})\n\n# Check the number of unique nodes/edges in the graph and earliest/latest time seen.\nprint(graph)\n\nresults = [[\"earliest_time\", \"name\", \"out_degree\", \"in_degree\"]]\n\n# Collect some simple node metrics Ran across the history of your graph with a rolling window\nfor graph_view in graph.rolling(window=1):\n    for v in graph_view.nodes:\n        results.append(\n            [graph_view.earliest_time, v.name, v.out_degree(), v.in_degree()]\n        )\n\n# Print the results\nprint(pd.DataFrame(results[1:], columns=results[0]))\n\n# Grab an edge, explore the history of its 'weight'\ncb_edge = graph.edge(\"Bob\", \"Charlie\")\nweight_history = cb_edge.properties.temporal.get(\"weight\").items()\nprint(\n    \"The edge between Bob and Charlie has the following weight history:\", weight_history\n)\n\n# Compare this weight between time 2 and time 3\nweight_change = cb_edge.at(2)[\"weight\"] - cb_edge.at(3)[\"weight\"]\nprint(\n    \"The weight of the edge between Bob and Charlie has changed by\",\n    weight_change,\n    \"pts\",\n)\n\n# Run pagerank and ask for the top ranked node\ntop_node = algo.pagerank(graph).top_k(1).max_item()\nprint(\n    \"The most important node in the graph is\",\n    top_node[0].name,\n    \"with a score of\",\n    top_node[1],\n)\n</code></pre></p> <p>Output</p> <p><pre><code>Graph(number_of_nodes=3, number_of_edges=2, number_of_temporal_edges=3, earliest_time=1, latest_time=3)\n   earliest_time     name  out_degree  in_degree\n0              1    Alice           0          0\n1              1      Bob           0          0\n2              1  Charlie           0          0\n3              2      Bob           1          0\n4              2  Charlie           0          1\n5              3    Alice           1          0\n6              3      Bob           1          1\n7              3  Charlie           0          1\nThe edge between Bob and Charlie has the following weight history: [(2, 5.0), (3, -15.0)]\nThe weight of the edge between Bob and Charlie has changed by 20.0 pts\nThe most important node in the graph is Charlie with a score of 0.4744116163405977\n</code></pre> </p>"},{"location":"#graphql-playground","title":"GraphQL Playground","text":"<p>Once you have built some graphs, you can easily host them via Graphql. When you host a Raphtory GraphQL server you get a web playground bundled in, accessible on the same port within your browser (defaulting to 1736). Here you can experiment with queries on your graphs and explore the schema. An example of the playground can be seen below, running a similar query as in the python example above.</p> <p></p>"},{"location":"#graph-visualisation-and-explorations","title":"Graph Visualisation and Explorations","text":"<p>Once the GraphQL server is running, you can access the UI directly. If the server is hosted on port 1736, the UI will be available at http://localhost:1736. The UI allows you to search for data in Raphtory, explore connections, and visualise the graph effortlessly.</p> <p></p>"},{"location":"#excited-to-give-it-a-go","title":"Excited to give it a go?","text":"<p>This site has been created to get new users of <code>Raphtory</code> up to speed by explaining the most important features via meaningful examples. You can get started straight away by heading to the User Guide. If you prefer learning via APIs and reading into specific object or functions, your best best it to visit the API documentation: Python | Rust.</p>"},{"location":"#community","title":"Community","text":"<p>Join the growing community of open-source enthusiasts using Raphtory to power their graph analysis projects!</p> <ul> <li> <p>Follow  for the latest Raphtory news and development</p> </li> <li> <p>Join our  to chat with us and get answers to your questions!</p> </li> </ul> <p> </p>"},{"location":"#sponsors","title":"Sponsors","text":""},{"location":"#contribute","title":"Contribute","text":"<p>The best way to start contributing is to give Raphtory a  on github! Once you have done that, if you want to raise an issue, submit a PR or give us some feedback, you can checkout our Contributing Guide, the open list of issues, or hit us up directly on slack. </p>"},{"location":"#license","title":"License","text":"<p>Raphtory is licensed under the terms of the GNU General Public License v3.0.</p>"},{"location":"api/","title":"Raphtory APIs","text":"<p>Once you are comfortable with the basics of Raphtory you can start digging into the full APIs for your own projects. Below you will find links to the API documentation for all our supported languages:</p> <p>Rust</p> <p>docs.rs/raphtory/</p> <p>Python</p> <p>docs.raphtory.com</p>"},{"location":"open-house/","title":"Raphtory Open House","text":"<p>Join us once a month virtually for a coffee and to hear the latest news about Raphtory. Our open house session is for:</p> <ul> <li>Discussion of new and in-progress Raphtory features</li> <li>Hearing from researchers who are using Raphtory or temporal networks</li> <li>Making requests for new features or functionality</li> <li>Temporal graph surgery: get help for bugs or anything in Raphtory you're struggling to get going with</li> </ul> <p>The next event will be on Wednesday 3rd April at 11am GMT. The topics for this meeting will be:</p> <ol> <li>Raphtory latest news (Pometry development team)</li> <li>Combining AI with Raphtory (Cheick Ba)</li> <li>Using Raphtory in your research (Richard Clegg)</li> </ol> <p>Join the Zoom meeting here.</p> <p>If you want to add the recurring event to your calendar, follow the link below:</p> <p></p>"},{"location":"people/","title":"People","text":""},{"location":"user-guide/graph-deletions/","title":"Graphs with deletions","text":"<p> Under Construction  </p> <p>The Raphtory project has just migrated to a new website and is doing a full revamp of the documentation - please checkout docs.raphtory.com whilst this section is being updated.</p>"},{"location":"user-guide/graphql/","title":"Exposing your graph via GraphQL","text":"<p> Under Construction  </p> <p>The Raphtory project has just migrated to a new website and is doing a full revamp of the documentation - please checkout docs.raphtory.com whilst this section is being updated.</p>"},{"location":"user-guide/installation/","title":"Installation","text":"<p>Raphtory is a library for Python and Rust. Installation is as simple as invoking the package manager of the corresponding programming language.</p>  Python Rust <pre><code>pip install raphtory\n</code></pre> <pre><code>cargo add raphtory\n\n# Or Cargo.toml\n[dependencies]\nraphtory = { version = \"x\"}\n</code></pre>"},{"location":"user-guide/installation/#importing","title":"Importing","text":"<p>To use the library import it into your project</p>  Python Rust <pre><code>import raphtory as rp\n</code></pre> <pre><code>use raphtory::prelude::*;\n</code></pre>"},{"location":"user-guide/algorithms/1_intro/","title":"Running algorithms","text":"<p>Within Raphtory we have implemented many of the standard algorithms you may expect within a graph library, but have also added several temporal algorithms such as <code>Temporal Reachability</code> and <code>Temporal Motifs</code>. </p> <p>Before we look at the different types of algorithms, let's first load in some data. For these examples we are going to use the One graph to rule them all dataset, which maps the co-occurrence of characters within the Lord of The Rings books. This dataset is a simple edge list, consisting of the source character, destination character and the sentence they occurred together in (which we shall use as a timestamp). The dataframe for this can be seen in the output below.</p>  Python <p> <code>Graph</code> <pre><code>from raphtory import Graph\nimport pandas as pd\n\ndf = pd.read_csv(\"data/lotr.csv\")\nprint(df)\n\nlotr_graph = Graph()\nlotr_graph.load_edges_from_pandas(\n    df=df,time=\"time\", src=\"src\", dst=\"dst\"\n)\n</code></pre></p> <p>Output</p> <p><pre><code>            src        dst   time\n0       Gandalf     Elrond     33\n1         Frodo      Bilbo    114\n2        Blanco     Marcho    146\n3         Frodo      Bilbo    205\n4        Thorin    Gandalf    270\n...         ...        ...    ...\n2644      Merry  Galadriel  32666\n2645      Merry        Sam  32666\n2646  Galadriel        Sam  32666\n2647     Pippin      Merry  32671\n2648     Pippin      Merry  32674\n\n[2649 rows x 3 columns]\n</code></pre> </p>"},{"location":"user-guide/algorithms/2_graph-algorithms/","title":"Graph wide algorithms","text":"<p>The first category of algorithms we can run are <code>graph wide</code>, returning one value for the whole graph. There are many useful metrics that fall into this category, of which we run three in the code below:</p> <ul> <li>Graph Density - which represents the ratio between the edges present in a graph and the maximum number of edges that the graph could contain.</li> <li>Clustering coefficient - which is a measure of the degree to which nodes in a graph tend to cluster together e.g. how many of your friends are also friends.</li> <li>Reciprocity - which is a measure of the likelihood of nodes in a directed network to be mutually connected e.g. if you follow someone on twitter, whats the change of them following you back.</li> </ul> <p>As you can see below, to run an algorithm you simply need to import the algorithm package, choose an algorithm to run and hand it your graph.</p>  Python <p> <code>Graph</code> <pre><code>from raphtory import algorithms as rp\n\ndensity = rp.directed_graph_density(lotr_graph)\nclustering_coefficient = rp.global_clustering_coefficient(lotr_graph)\nreciprocity = rp.global_reciprocity(lotr_graph)\n\nprint(f\"The graph's density is {density}\")\nprint(f\"The graph's clustering coefficient is {clustering_coefficient}\")\nprint(f\"The graph's reciprocity is {reciprocity}\")\n</code></pre></p> <p>Output</p> <p><pre><code>The graph's density is 0.03654467730163695\nThe graph's clustering coefficient is 0.4163023913602468\nThe graph's reciprocity is 0.19115549215406563\n</code></pre> </p>"},{"location":"user-guide/algorithms/3_node-algorithms/","title":"Node centric algorithms","text":"<p>The second category of algorithms are <code>node centric</code> and return a value for each node in the graph. These results are stored within a <code>NodeState</code> object which has functions for sorting, grouping, top_k and conversion to dataframes. To demonstrate these functions below we have run PageRank and Weakly Connected Components.</p>"},{"location":"user-guide/algorithms/3_node-algorithms/#continuous-results-pagerank","title":"Continuous Results (PageRank)","text":"<p><code>PageRank</code> is an centrality metric developed by Google's founders to rank web pages in search engine results based on their importance and relevance. This has since become a standard ranking algorithm for a whole host of other usecases.</p> <p>Raphtory's implementation returns the score for each node - these are continuous values, meaning we can discover the most important characters in our Lord of the Rings dataset via <code>top_k()</code>.</p> <p>In the code below we first get the result of an individual character (Gandalf), followed by the values of the top 5 most important characters. </p>  Python <p> <code>Graph</code> <pre><code>from raphtory import algorithms as rp\n\nresults = rp.pagerank(lotr_graph)\n\n# Getting the results for an individual character (Gandalf)\ngandalf_rank = results.get(\"Gandalf\")\nprint(f\"Gandalf's ranking is {gandalf_rank}\\n\")\n\n# Getting the top 5 most important characters and printing out their scores\ntop_5 = results.top_k(5)\nfor rank, (node, score) in enumerate(top_5.items(),1):\n    print(f\"Rank {rank}: {node.name} with a score of {score:.5f}\")\n</code></pre></p> <p>Output</p> <p><pre><code>Gandalf's ranking is 0.015810830531114206\n\nRank 1: Aragorn with a score of 0.09526\nRank 2: Faramir with a score of 0.06148\nRank 3: Elrond with a score of 0.04042\nRank 4: Boromir with a score of 0.03468\nRank 5: Legolas with a score of 0.03323\n</code></pre> </p>"},{"location":"user-guide/algorithms/3_node-algorithms/#discrete-results-connected-components","title":"Discrete Results (Connected Components)","text":"<p><code>Weakly connected components</code> in a directed graph are <code>subgraphs</code> where every node is reachable from every other node (if edge direction is ignored). </p> <p>This algorithm returns the id of the component each node is a member of - these are discrete values, meaning we can use <code>groups</code> to find additional insights like the size of the largest connected component. </p> <p>In the code below we first run the algorithm and print the result so we can see what it looks like. </p> <p>Info</p> <p>The <code>component ID (value)</code> is generated from the lowest <code>node ID</code> in the component.</p> <p>Next we take the results and group the nodes by these IDs and calculate the size of the largest component. </p> <p>Info</p> <p>Almost all nodes are within this component (134 of the 139), as is typical for social networks.</p>  Python <p> <code>Graph</code> <pre><code>from raphtory import algorithms as rp\n\nresults = rp.weakly_connected_components(lotr_graph)\n\nprint(f\"{results}\\n\")\n\n# Group the components together\ncomponents = results.groups()\n\n# Get the size of each component\ncomponent_sizes = {key: len(value) for key, value in components}\n# Get the key for the largest component\nlargest_component = max(component_sizes, key=component_sizes.get)\n# Print the size of the largest component\nprint(\n    f\"The largest component contains {component_sizes[largest_component]} of the {lotr_graph.count_nodes()} nodes in the graph.\"\n)\n</code></pre></p> <p>Output</p> <p><pre><code>NodeState(Gandalf: 0, Frodo: 0, Blanco: 2, Thorin: 0, Gollum: 0, Bilbo: 0, Peregrin: 0, Arwen: 0, Barahir: 0, Elrond: 0, ...)\n\nThe largest component contains 134 of the 139 nodes in the graph.\n</code></pre> </p>"},{"location":"user-guide/algorithms/4_view-algorithms/","title":"Running algorithms on graph views","text":"<p>As with all the queries we saw in the previous chapter, both <code>graphwide</code> and <code>node centric</code> algorithms can be run on <code>graph views</code>. This allows us to see how results change over time, run algorithms on subsets of the layers or remove specific nodes from the graph to see the impact this has. </p> <p>To demonstrate this, below is an example of how you could track Gandaf's importance over the course of the story using rolling windows and the <code>PageRank</code> algorithm. </p> <p>Within each windowed graph we use the <code>NodeState</code> api to extract Gandalf's score and record it alongside the earliest timestamp in the window, which can then be plotted via matplotlib.</p>  Python <p> <code>Graph</code> <pre><code># mkdocs: render\nimport matplotlib.pyplot as plt\nimport pandas as pd\nfrom raphtory import algorithms as rp\nfrom raphtory import Graph\n\ndf = pd.read_csv(\"data/lotr.csv\")\nlotr_graph = Graph()\nlotr_graph.load_edges_from_pandas(\n    df=df, src=\"src\", dst=\"dst\", time=\"time\"\n)\n\nimportance = []\ntime = []\n\nfor windowed_graph in lotr_graph.rolling(window=2000):\n    result = rp.pagerank(windowed_graph)\n    importance.append(result.get(\"Gandalf\"))\n    time.append(windowed_graph.earliest_time)\n\nplt.plot(time, importance, marker=\"o\")\nplt.xlabel(\"Sentence (Time)\")\nplt.ylabel(\"Pagerank Score\")\nplt.title(\"Gandalf's importance over time\")\nplt.grid(True)\n</code></pre></p>"},{"location":"user-guide/export/1_intro/","title":"Exporting and visualising your graph","text":"<p>As with Raphtory's connectors for ingesting data, there are a host of different formats and libraries that you can export your graphs into. Below we explore two of these, namely Pandas dataframes and NetworkX graphs.</p> <p>All functions mentioned in this section work on both <code>graphs/nodes/edges</code> and <code>graph/node/edge views</code>, allowing you to specify different windows, layers and subgraphs before conversion. </p> <p>By default exporting will include all properties and all update history. However, this can be modified via flags on each export function, depending on use case requirements. You can find a description of these flags in the API docs for the function. </p> <p>Info</p> <p>If we are missing a format that you believe to be important, please raise an issue and it will be available before you know it!</p> <p>For the examples in this tutorial we are going to be reusing the network traffic dataset from the ingestion tutorial and the monkey interaction network from the querying tutorial. In the below code segment you can get a refresher of what these datasets looks like. </p>  Python <p> <code>Graph</code> <pre><code>from raphtory import Graph\nimport pandas as pd\n\nserver_edges_df = pd.read_csv(\"data/network_traffic_edges.csv\")\nserver_edges_df[\"timestamp\"] = pd.to_datetime(server_edges_df[\"timestamp\"])\n\nserver_nodes_df = pd.read_csv(\"data/network_traffic_nodes.csv\")\nserver_nodes_df[\"timestamp\"] = pd.to_datetime(server_nodes_df[\"timestamp\"])\n\nprint(\"Network Traffic Edges:\")\nprint(f\"{server_edges_df}\\n\")\nprint(\"Network Traffic Servers:\")\nprint(f\"{server_nodes_df}\\n\")\n\ntraffic_graph = Graph()\ntraffic_graph.load_edges_from_pandas(\n    df=server_edges_df,\n    src=\"source\",\n    dst=\"destination\",\n    time=\"timestamp\",\n    properties=[\"data_size_MB\"],\n    layer_col=\"transaction_type\",\n    constant_properties=[\"is_encrypted\"],\n    shared_constant_properties={\"datasource\": \"data/network_traffic_edges.csv\"},\n)\ntraffic_graph.load_nodes_from_pandas(\n    df=server_nodes_df,\n    id=\"server_id\",\n    time=\"timestamp\",\n    properties=[\"OS_version\", \"primary_function\", \"uptime_days\"],\n    constant_properties=[\"server_name\", \"hardware_type\"],\n    shared_constant_properties={\"datasource\": \"data/network_traffic_edges.csv\"},\n)\n\nmonkey_edges_df = pd.read_csv(\n    \"data/OBS_data.txt\", sep=\"\\t\", header=0, usecols=[0, 1, 2, 3, 4], parse_dates=[0]\n)\nmonkey_edges_df[\"DateTime\"] = pd.to_datetime(monkey_edges_df[\"DateTime\"])\nmonkey_edges_df.dropna(axis=0, inplace=True)\nmonkey_edges_df[\"Weight\"] = monkey_edges_df[\"Category\"].apply(\n    lambda c: 1 if (c == \"Affiliative\") else (-1 if (c == \"Agonistic\") else 0)\n)\n\nprint(\"Monkey Interactions:\")\nprint(f\"{monkey_edges_df}\\n\")\n\nmonkey_graph = Graph()\nmonkey_graph.load_edges_from_pandas(\n    df=monkey_edges_df,\n    src=\"Actor\",\n    dst=\"Recipient\",\n    time=\"DateTime\",\n    layer_col=\"Behavior\",\n    properties=[\"Weight\"],\n)\n</code></pre></p> <p>Output</p> <p><pre><code>Network Traffic Edges:\n                  timestamp   source  ...          transaction_type  is_encrypted\n0 2023-09-01 08:00:00+00:00  ServerA  ...   Critical System Request          True\n1 2023-09-01 08:05:00+00:00  ServerA  ...             File Transfer         False\n2 2023-09-01 08:10:00+00:00  ServerB  ...  Standard Service Request          True\n3 2023-09-01 08:15:00+00:00  ServerD  ...    Administrative Command         False\n4 2023-09-01 08:20:00+00:00  ServerC  ...   Critical System Request          True\n5 2023-09-01 08:25:00+00:00  ServerE  ...             File Transfer         False\n6 2023-09-01 08:30:00+00:00  ServerD  ...  Standard Service Request          True\n\n[7 rows x 6 columns]\n\nNetwork Traffic Servers:\n                  timestamp server_id  ...    primary_function uptime_days\n0 2023-09-01 08:00:00+00:00   ServerA  ...            Database         120\n1 2023-09-01 08:05:00+00:00   ServerB  ...          Web Server          45\n2 2023-09-01 08:10:00+00:00   ServerC  ...        File Storage          90\n3 2023-09-01 08:15:00+00:00   ServerD  ...  Application Server          60\n4 2023-09-01 08:20:00+00:00   ServerE  ...              Backup          30\n\n[5 rows x 7 columns]\n\nMonkey Interactions:\n                DateTime    Actor Recipient      Behavior     Category  Weight\n15   2019-06-13 09:50:00   ANGELE    FELIPE      Grooming  Affiliative       1\n17   2019-06-13 09:50:00   ANGELE    FELIPE      Grooming  Affiliative       1\n19   2019-06-13 09:51:00   FELIPE    ANGELE       Resting  Affiliative       1\n20   2019-06-13 09:51:00   FELIPE      LIPS       Resting  Affiliative       1\n21   2019-06-13 09:51:00   ANGELE    FELIPE      Grooming  Affiliative       1\n...                  ...      ...       ...           ...          ...     ...\n5370 2019-07-10 11:02:00  ARIELLE      LIPS      Touching  Affiliative       1\n5371 2019-07-10 11:05:00     LIPS     NEKKE  Playing with  Affiliative       1\n5372 2019-07-10 11:05:00     LIPS    FELIPE       Resting  Affiliative       1\n5373 2019-07-10 11:05:00     LIPS     NEKKE       Resting  Affiliative       1\n5374 2019-07-10 11:05:00     LIPS    FELIPE       Resting  Affiliative       1\n\n[3196 rows x 6 columns]\n</code></pre> </p>"},{"location":"user-guide/export/2_dataframes/","title":"Exporting to Pandas dataframes","text":"<p>As we are ingesting from a set of dataframes, let's kick off by looking at how to convert back into them. For this Raphtory provides the <code>to_df()</code> function on both the <code>Nodes</code> and <code>Edges</code>. </p>"},{"location":"user-guide/export/2_dataframes/#node-dataframe","title":"Node Dataframe","text":"<p>To explore the use of <code>to_df()</code> on the nodes we can first we call the function with default parameters. This exports only the latest property updates and utilises epoch timestamps - the output from this can be seen below. </p> <p>To demonstrate the flags which can be utilised, we call <code>to_df()</code> again, this time enabling the property history and utilising datetime timestamps. The output for this can also be seen below.</p>  Python <p> <code>Graph</code> <pre><code>df = traffic_graph.nodes.to_df()\nprint(\"--- to_df with default parameters --- \")\nprint(f\"{df}\\n\")\nprint()\ndf = traffic_graph.nodes.to_df(include_property_history=True, convert_datetime=True)\nprint(\"--- to_df with property history and datetime conversion ---\")\nprint(f\"{df}\\n\")\n</code></pre></p> <p>Output</p> <p><pre><code>--- to_df with default parameters --- \n      name type  ... uptime_days                                     update_history\n0  ServerD       ...          60      [1693555800000, 1693556100000, 1693557000000]\n1  ServerC       ...          90  [1693555500000, 1693555800000, 1693556400000, ...\n2  ServerE       ...          30      [1693556100000, 1693556400000, 1693556700000]\n3  ServerB       ...          45  [1693555200000, 1693555500000, 1693555800000, ...\n4  ServerA       ...         120      [1693555200000, 1693555500000, 1693556400000]\n\n[5 rows x 9 columns]\n\n\n--- to_df with property history and datetime conversion ---\n      name  ...                                     update_history\n0  ServerD  ...  [2023-09-01 08:10:00+00:00, 2023-09-01 08:15:0...\n1  ServerC  ...  [2023-09-01 08:05:00+00:00, 2023-09-01 08:10:0...\n2  ServerE  ...  [2023-09-01 08:15:00+00:00, 2023-09-01 08:20:0...\n3  ServerB  ...  [2023-09-01 08:00:00+00:00, 2023-09-01 08:05:0...\n4  ServerA  ...  [2023-09-01 08:00:00+00:00, 2023-09-01 08:05:0...\n\n[5 rows x 9 columns]\n</code></pre> </p>"},{"location":"user-guide/export/2_dataframes/#edge-dataframe","title":"Edge Dataframe","text":"<p>Exporting to an edge dataframe via <code>to_df()</code> works the same as for the nodes. The only difference is by default this will export the property history for each edge, split by edge layer. This is because this function has an alternative flag to explode the edges and view each update individually (which will then ignore the <code>include_property_history</code> flag). </p> <p>In the below example we first create a subgraph of the monkey interactions, selecting some monkeys we are interested in (<code>ANGELE</code> and <code>FELIPE</code>). This isn't a required step, but is to demonstrate the export working on graph views. </p> <p>We then call <code>to_df()</code> on the subgraph edges, setting no flags. In the output you can see the property history for each interaction type (layer) between <code>ANGELE</code> and <code>FELIPE</code>.</p> <p>Finally, we call <code>to_df()</code> again, turning off the property history and exploding the edges. In the output you can see each interaction which occurred between <code>ANGELE</code> and <code>FELIPE</code>.</p> <p>Info</p> <p>We have further reduced the graph to only one layer (<code>Grunting-Lipsmacking</code>) to reduce the output size.</p>  Python <p> <code>Graph</code> <pre><code>subgraph = monkey_graph.subgraph([\"ANGELE\", \"FELIPE\"])\ndf = subgraph.edges.to_df()\nprint(\"Interactions between Angele and Felipe:\")\nprint(f\"{df}\\n\")\n\ngrunting_graph = subgraph.layer(\"Grunting-Lipsmacking\")\nprint(grunting_graph)\nprint(grunting_graph.edges)\ndf = grunting_graph.edges.to_df()\nprint(\"Exploding the grunting-Lipsmacking layer\")\nprint(df)\n</code></pre></p> <p>Output</p> <p><pre><code>Interactions between Angele and Felipe:\n       src  ...                                     update_history\n0   ANGELE  ...  [1560419400000, 1560419400000, 1560419460000, ...\n1   ANGELE  ...  [1560422580000, 1560441780000, 1560441780000, ...\n2   ANGELE  ...                                    [1560855660000]\n3   ANGELE  ...      [1560526320000, 1560855660000, 1561042620000]\n4   ANGELE  ...                                    [1561720320000]\n5   ANGELE  ...                                    [1562253540000]\n6   FELIPE  ...  [1560419460000, 1560419520000, 1560419580000, ...\n7   FELIPE  ...                                    [1562321580000]\n8   FELIPE  ...      [1560526260000, 1562253540000, 1562321580000]\n9   FELIPE  ...      [1560526320000, 1561972860000, 1562253540000]\n10  FELIPE  ...                     [1562057520000, 1562671200000]\n11  FELIPE  ...                                    [1562253540000]\n12  FELIPE  ...                                    [1560526320000]\n13  FELIPE  ...                                    [1561110180000]\n14  FELIPE  ...                                    [1562057520000]\n\n[15 rows x 5 columns]\n\nGraph(number_of_nodes=2, number_of_edges=2, number_of_temporal_edges=6, earliest_time=1560419400000, latest_time=1562756700000)\nEdges(Edge(source=ANGELE, target=FELIPE, earliest_time=1560526320000, latest_time=1561042620000, properties={Weight: 1}, layer(s)=[Grunting-Lipsmacking]), Edge(source=FELIPE, target=ANGELE, earliest_time=1560526320000, latest_time=1562253540000, properties={Weight: 1}, layer(s)=[Grunting-Lipsmacking]))\nExploding the grunting-Lipsmacking layer\n      src  ...                                 update_history\n0  ANGELE  ...  [1560526320000, 1560855660000, 1561042620000]\n1  FELIPE  ...  [1560526320000, 1561972860000, 1562253540000]\n\n[2 rows x 5 columns]\n</code></pre> </p>"},{"location":"user-guide/export/3_networkx/","title":"Exporting to NetworkX","text":"<p>For converting to a networkx graph there is only one function (<code>to_networkx()</code>), which has flags for node/edge history and for exploding edges. By default all history is included and the edges are separated by layer. </p> <p>In the below code snippet we call <code>to_networkx()</code> on the network traffic graph, keeping all the default arguments and, therefore, exporting the full history. We have extracted <code>ServerA</code> from this graph and printed it so that you may see how the history is modelled. </p> <p>Info</p> <p>Note that the resulting graph is a networkx <code>MultiDiGraph</code> as Raphtory graphs are both directed and have multiple edges between nodes.</p> <p>We then call <code>to_networkx()</code> again, disabling the property/update history and reprint <code>ServerA</code> allowing you to see the difference.   </p>  Python <p> <code>Graph</code> <pre><code>nx_g = traffic_graph.to_networkx()\n\nprint(\"Networkx graph:\")\nprint(nx_g)\nprint()\nprint(\"Full property history of ServerA:\")\nprint(nx_g.nodes[\"ServerA\"])\nprint()\n\nnx_g = traffic_graph.to_networkx(include_property_history=False)\n\nprint(\"Only the latest properties of ServerA:\")\nprint(nx_g.nodes[\"ServerA\"])\n</code></pre></p> <p>Output</p> <p><pre><code>Networkx graph:\nMultiDiGraph with 5 nodes and 7 edges\n\nFull property history of ServerA:\n{'constant': {'datasource': 'data/network_traffic_edges.csv', 'server_name': 'Alpha', 'hardware_type': 'Blade Server'}, 'temporal': [('OS_version', (1693555200000, 'Ubuntu 20.04')), ('primary_function', (1693555200000, 'Database')), ('uptime_days', (1693555200000, 120))], 'update_history': [1693555200000, 1693555500000, 1693556400000]}\n\nOnly the latest properties of ServerA:\n{'hardware_type': 'Blade Server', 'primary_function': 'Database', 'OS_version': 'Ubuntu 20.04', 'datasource': 'data/network_traffic_edges.csv', 'server_name': 'Alpha', 'uptime_days': 120, 'update_history': [1693555200000, 1693555500000, 1693556400000]}\n</code></pre> </p>"},{"location":"user-guide/export/3_networkx/#visualisation","title":"Visualisation","text":"<p>Once converted into a networkX graph you are free to use their full suite of functionality. One great use of this conversion is to make use of their drawing library for visualising graphs.</p> <p>In the code snippet below we use this functionality to draw the network traffic graph, labelling the nodes with their Server ID. These visualisations can become as complex as your like, but we refer you to the networkx documentation for this.</p>  Python <p> <code>Graph</code> <pre><code># mkdocs: render\nimport matplotlib.pyplot as plt\nimport networkx as nx\n\nfrom raphtory import Graph\nimport pandas as pd\n\nserver_edges_df = pd.read_csv(\"data/network_traffic_edges.csv\")\nserver_edges_df[\"timestamp\"] = pd.to_datetime(server_edges_df[\"timestamp\"])\n\ntraffic_graph = Graph()\ntraffic_graph.load_edges_from_pandas(\n    df=server_edges_df,\n    time=\"timestamp\",\n    src=\"source\",\n    dst=\"destination\",\n)\n\nnx_g = traffic_graph.to_networkx()\nnx.draw(nx_g, with_labels=True, node_color=\"lightblue\", edge_color=\"gray\")\n</code></pre></p>"},{"location":"user-guide/export/4_pyvis/","title":"Exporting to Pyvis","text":"<p>For a more interactive visualisation you can export your graphs to Pyvis, a network visualisation library built on top of VisJS.</p> <p>Due to the nature of Pyvis's model and API, the parameters for <code>to_pyvis()</code> are quite different to the other export functions discussed previously. These are split between Raphtory specific parameters and a <code>kwargs</code> (key word arguments) map which is passed directly to the pyvis graph during initialisation.</p> <p>Info</p> <p>The Raphtory specific parameters are used to explode the edges and for setting values which are immutable after an edge/node has been inserted into the pyvis model (such as an edges colour or weight). The description of these arguments can be found in the functions documentation. </p> <p>The <code>kwargs</code> for pyvis are described in their own documentation. These values can also be dynamically set on the pyvis graph, allowing you to experiment with different values without reexporting. This is useful when fine turing elements such as the strength of the gravity in the physics engine.</p> <p>In the code below we first call <code>to_pyvis()</code> on the network traffic graph. Within this we set two Raphtory arguments (<code>edge_weight</code> and <code>edge_color</code>), specifying that an edge's thickness should be based on the amount of data sent between the servers it links. We then set a pyvis keyword (<code>directed</code>) to add arrows to the output, showing the direction of this traffic.</p> <p>Once the pyvis graph has been generated, we create and apply a style config, setting an appropriate layout algorithm.</p> <p>Finally, calling the <code>.show()</code> function creates a html file where the graph can be interacted with. This is embedded in an iframe below for you to try.</p>  Python <p> <code>Graph</code> <pre><code>import json\n\n\npyvis_g = traffic_graph.to_pyvis(\n    edge_weight=\"data_size_MB\", edge_color=\"#8e9b9e\", directed=True,notebook=False\n)\n\noptions = {\n    \"edges\": {\n        \"scaling\": {\n            \"min\": 1,\n            \"max\": 10,\n        },\n    },\n    \"physics\": {\n        \"barnesHut\": {\n            \"gravitationalConstant\": -30000,\n            \"centralGravity\": 0.3,\n            \"springLength\": 100,\n            \"springConstant\": 0.05,\n        },\n        \"maxVelocity\": 50,\n        \"timestep\": 0.5,\n    },\n}\n\npyvis_g.set_options(json.dumps(options))\n\npyvis_g.write_html(\"nx.html\")\n</code></pre></p>"},{"location":"user-guide/graphql/1_intro/","title":"Introduction to GraphQL","text":"<p>GraphQL is a query language that allows you to retrieve exactly what you need from your data, making interactions more efficient. By utilising GraphQL to define the structure of the response, we can reduce over-fetching and under-fetching of data compared to other REST APIs.</p> <p>It is possible to run Raphtory graphs in GraphQL. The GraphQL IDE is run on the GraphQL server itself (e.g. http://localhost:1736/playground) and you will immediately be able to write GraphQL queries on the IDE.</p> <p>Alternatively, you can write all your GraphQL queries in Python, which is still connected to the GraphQL server (e.g. http://localhost:1736/). With this, you will be able to easily update, send and receive Raphtory graphs from the server.</p> <p>In the following tutorials, we will guide you through how to run your own GraphQL server so that you can write your own GraphQL queries for your data.</p>"},{"location":"user-guide/graphql/2_run-server/","title":"Running the GraphQL Server","text":"<p>Before you run the GraphQL server, you will need to follow our tutorials on how to get your data into Raphtory. These tutorials can be found following this link.</p>"},{"location":"user-guide/graphql/2_run-server/#saving-your-raphtory-graph-into-a-directory","title":"Saving your Raphtory graph into a directory","text":"<p>Once your graph is loaded into Raphtory, the graph needs to be saved into your working directory. This can be done with the following code snippet (change <code>g</code> to the constant that your Raphtory graph is saved under):</p>  Python <pre><code>import os\nworking_dir = \"graphs/\"\n\nif not os.path.exists(working_dir):\n    os.makedirs(working_dir)\ng.save_to_file(working_dir + \"your_graph\")\n</code></pre>"},{"location":"user-guide/graphql/2_run-server/#starting-a-server-with-run","title":"Starting a server with .run()","text":"<p>To run the GraphQL server with <code>.run()</code>, create a python file <code>run_server.py</code> with the following code:</p>  Python <pre><code>from raphtory import graphql\n\nimport argparse\nparser = argparse.ArgumentParser(description=\"For passing the working_dir\")\nparser.add_argument(\n    \"--working_dir\",\n    type=str,\n    help=\"path for the working directory of the raphtory server\",\n)\nargs = parser.parse_args()\n\nserver = graphql.GraphServer(args.working_dir)\n\nserver.run()\n</code></pre> <p>To run the server, type this command into the terminal:</p> <pre><code>python run_server.py --working_dir ../your_working_dir\n</code></pre>"},{"location":"user-guide/graphql/2_run-server/#starting-a-server-with-start","title":"Starting a server with .start()","text":"<p>It is also possible to start the server in Python with <code>.start()</code>. This is an example of how to start the server and send a Raphtory graph to the server (rename <code>new_graph</code> to your Raphtory graph object).</p>  Python <pre><code>tmp_work_dir = tempfile.mkdtemp()\nwith GraphServer(tmp_work_dir, tracing=True).start():\n    client = RaphtoryClient(\"http://localhost:1736\")\n    client.send_graph(path=\"g\", graph=new_graph)\n\n    query = \"\"\"{graph(path: \"g\") {nodes {list {name}}}}\"\"\"\n    client.query(query)\n</code></pre> <p>You can set the port in <code>RaphtoryClient()</code> to the port that you desire the GraphQL server to be run on.</p> <p>The path parameter is always the graph in your server that you would like to change/read. So in this example, we want to send new_graph to graph \"g\" on the server.</p> <p>The graph parameter is set to the Raphtory graph that we would like to send. An additional <code>overwrite</code> parameter can be stated if we want this new graph to overwrite the old graph.</p>"},{"location":"user-guide/graphql/3_writing-queries/","title":"Writing Raphtory queries in GraphQL","text":"<p>Once you have started your GraphQL server, you will be able to find your GraphQL UI in the browser via the port that you set.</p> <p>The schema for the queries can be found on the right hand side in a pull out toggle. </p>"},{"location":"user-guide/graphql/3_writing-queries/#example-queries-in-graphql","title":"Example Queries in GraphQL","text":"<p>Here are some example queries to get you started:</p> <p>Query to show list of all the nodes</p> <pre><code>query {\n    graph(path: \"your_graph\") {\n        nodes {\n            list {\n                name\n            }\n        }\n    }\n}\n</code></pre> <p>Query to show list of all the edges, with node properties <code>age</code>.</p> <pre><code>query {\n    graph(path: \"your_graph\") {\n        edges {\n            list {\n                src {\n                    name\n                    properties {\n                        get(key:\"age\") {\n                            value\n                        }\n                    }\n                }\n                dst {\n                    name\n                    properties {\n                        get(key:\"age\") {\n                            value\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n</code></pre> <p>This will return something like this:</p> <pre><code>{\n  \"data\": {\n    \"graph\": {\n      \"edges\": {\n        \"list\": [\n          {\n            \"src\": {\n              \"name\": \"Ben\",\n              \"properties\": {\n                \"get\": {\n                  \"value\": 30\n                }\n              }\n            },\n            \"dst\": {\n              \"name\": \"Hamza\",\n              \"properties\": {\n                \"get\": {\n                  \"value\": 30\n                }\n              }\n            }\n          },\n        ]\n      }\n    }\n  }\n}\n</code></pre> <p>All the queries that can be done in Python can also be done in GraphQL.</p> <p>Here is an example:</p>  Python GraphQL <pre><code>g.node(\"Ben\").properties.get(\"age\")\n</code></pre> <pre><code>query {\ngraph(path: \"your_graph\") {\nnode(name: \"Ben\") {\nproperties {\nget(key: \"age\") {\nvalue\n}\n}\n}\n}\n}\n</code></pre>"},{"location":"user-guide/graphql/3_writing-queries/#querying-graphql-in-python","title":"Querying GraphQL in Python","text":"<p>It is possible to send GraphQL queries in Python without the in-browser IDE. This can be handy if you would like to update your Raphtory graph in Python. Here is some example code that shows you how to do this with the Raphtory client:</p> <pre><code>with GraphServer(work_dir).start():\n    client = RaphtoryClient(\"http://localhost:1736\")\n\n    query = \"\"\"{graph(path: \"graph\") { created lastOpened lastUpdated }}\"\"\"\n    result = client.query(query)\n</code></pre> <p>Simply pass your graph object string into the client.query() method to execute the GraphQL query and retrieve the result in a python dictionary object.</p> <pre><code>{'graph': {'created': 1729075008085, 'lastOpened': 1729075036222, 'lastUpdated': 1729075008085}}\n</code></pre>"},{"location":"user-guide/graphql/3_writing-queries/#mutation-queries","title":"Mutation Queries","text":"<p>In GraphQL, you can write two different types of queries - a query to search through your data or a query that mutates your data.</p> <p>The examples in the previous section are all queries used to search through your data. However in our API, you are also able to mutate your graph. This can be done both in the GraphQL IDE and in Python.</p> <p>The schema in the GraphQL IDE shows how you can mutate the graph within the IDE: </p> <p>There are additional methods to mutate the graph exclusively in Python such as sending, receiving and updating a graph, these will all be explained below.</p>"},{"location":"user-guide/graphql/3_writing-queries/#sending-a-graph","title":"Sending a graph","text":"<p>You can send a graph to the server and overwrite an existing graph if needed.</p>  Python <pre><code>tmp_work_dir = tempfile.mkdtemp()\nwith GraphServer(tmp_work_dir).start():\n    client = RaphtoryClient(\"http://localhost:1736\")\n\n    g = Graph()\n    g.add_edge(1, \"bob\", \"emma\")\n    g.add_edge(2, \"sally\", \"tony\")\n    client.send_graph(path=\"g\", graph=g, overwrite=True)\n</code></pre> <p>To check your query:</p> <pre><code>  query = \"\"\"{graph(path: \"g\") {nodes {list {name}}}}\"\"\"\n  client.query(query)\n</code></pre> <p>This should return:</p> <pre><code>{\n    \"graph\": {\n        \"nodes\": {\n            \"list\": [\n                {\"name\": \"bob\"},\n                {\"name\": \"emma\"},\n                {\"name\": \"sally\"},\n                {\"name\": \"tony\"},\n            ]\n        }\n    }\n}\n</code></pre>"},{"location":"user-guide/graphql/3_writing-queries/#receiving-graphs","title":"Receiving graphs","text":"<p>You can receive graphs from a \"path\" from the server. From this, you will get a Python Raphtory graph object back from the server.</p> <pre><code> g = client.receive_graph(\"path/to/graph\")\n g.edge(\"sally\", \"tony\")\n</code></pre>"},{"location":"user-guide/graphql/3_writing-queries/#creating-a-new-graph","title":"Creating a new graph","text":"<p>This is an example of how to create a new graph in the server.</p> <p>The first parameter is the path of the graph to be created and the second parameter is the type of graph that should be created, this will either be EVENT or PERSISTENT. An explanation of the different types of graph can be found here</p>  GraphQL Python <pre><code>mutation {\nnewGraph(path: \"new_graph\", graphType: PERSISTENT)\n}\n</code></pre> <pre><code>work_dir = tempfile.mkdtemp()\nwith GraphServer(work_dir).start():\n    client = RaphtoryClient(\"http://localhost:1736\")\n    client.new_graph(\"path/to/new_graph\", \"EVENT\")\n</code></pre> <p>The returning result to confirm that a new graph has been created:</p> <pre><code>{\n\"data\": {\n\"newGraph\": true\n}\n}\n</code></pre>"},{"location":"user-guide/graphql/3_writing-queries/#moving-a-graph","title":"Moving a graph","text":"<p>It is possible to move a graph to a new path on the server.</p>  GraphQL Python <pre><code>mutation {\nmoveGraph(path: \"graph\", newPath: \"new_path\")\n}\n</code></pre> <pre><code>work_dir = tempfile.mkdtemp()\nwith GraphServer(work_dir).start():\n    client = RaphtoryClient(\"http://localhost:1736\")\n    client.move_graph(\"path/to/graph\", \"path/to/new_path)\n</code></pre> <p>The returning GraphQL result to confirm that the graph has been moved:</p> <pre><code>{\n\"data\": {\n\"moveGraph\": true\n}\n}\n</code></pre>"},{"location":"user-guide/graphql/3_writing-queries/#copying-a-graph","title":"Copying a graph","text":"<p>It is possible to copy a graph to a new path on the server.</p>  GraphQL Python <pre><code>mutation {\ncopyGraph(path: \"graph\", newPath: \"new_path\")\n}\n</code></pre> <pre><code>work_dir = tempfile.mkdtemp()\nwith GraphServer(work_dir).start():\n    client = RaphtoryClient(\"http://localhost:1736\")\n    client.copy_graph(\"path/to/graph\", \"path/to/new_path)\n</code></pre> <p>The returning GraphQL result to confirm that the graph has been copied:</p> <pre><code>{\n\"data\": {\n\"copyGraph\": true\n}\n}\n</code></pre>"},{"location":"user-guide/graphql/3_writing-queries/#deleting-a-graph","title":"Deleting a graph","text":"<p>It is possible to delete a graph on the server.</p>  GraphQL Python <pre><code>mutation {\ndeleteGraph(path: \"graph\")\n}\n</code></pre> <pre><code>work_dir = tempfile.mkdtemp()\nwith GraphServer(work_dir).start():\n    client = RaphtoryClient(\"http://localhost:1736\")\n    client.delete_graph(\"graph\")\n</code></pre> <p>The returning GraphQL result to confirm that the graph has been deleted:</p> <pre><code>{\n\"data\": {\n\"deleteGraph\": true\n}\n}\n</code></pre>"},{"location":"user-guide/graphql/3_writing-queries/#updating-the-graph","title":"Updating the graph","text":"<p>It is possible to update the graph using the <code>remote_graph()</code> method.</p>  Python <pre><code>work_dir = tempfile.mkdtemp()\n    with GraphServer(work_dir).start():\n        client = RaphtoryClient(\"http://localhost:1736\")\n        client.new_graph(\"path/to/event_graph\", \"EVENT\")\n        rg = client.remote_graph(\"path/to/event_graph\")\n        rg.add_edge(1, \"sally\", \"tony\", layer=\"friendship\")\n</code></pre> <p>Once you have updated the graph such as adding an edge, adding a node, removing an edge etc. You can receive a graph using <code>receive_graph()</code> and stating the path of the graph you would like to receive.</p>  Python <pre><code>g = client.receive_graph(\"path/to/event_graph\")\n</code></pre>"},{"location":"user-guide/graphql/4_running-ui/","title":"Running the UI","text":"<p>Want a flashy UI to display your Raphtory graph and data? Luckily, we have a UI that you can run from Raphtory with your data.</p> <p>To run the UI, you will first need to have the server running. To do this, follow the steps here. Once the server is running, the UI should be running on the port you have set.</p>"},{"location":"user-guide/graphql/4_running-ui/#search-page","title":"Search page","text":"<p>The search page of the UI is used to search and filter your data. For example, you can narrow your search by date, graph name and even node properties. You will be able to view a node's direct connections as well as its activity log and history. By double clicking on one of the results, you can navigate to the graph page where you will see a graphical representation of your data. The graph page is explained in the next section.</p> <p></p>"},{"location":"user-guide/graphql/4_running-ui/#graph-page","title":"Graph page","text":"<p>The graph page of the UI is used to explore your data and graph in an interactive way. Here you will be able to see all your nodes and edges in a clear format, with the ability to delete, expand and so much more. </p>"},{"location":"user-guide/ingestion/1_creating-a-graph/","title":"Creating a graph","text":"<p>There are plenty of ways to get data into Raphtory and start running analysis. In this tutorial we are going to cover three of the most versatile - direct updating, loading from a Pandas Dataframe and loading from a saved Raphtory graph. </p> <p>To get started we first need to create a graph to store our data. Printing this graph will show it as empty with no nodes, edges or update times.</p>  Python <p> <code>Graph</code> <pre><code>from raphtory import Graph\n\ng = Graph()\nprint(g)\n</code></pre></p> <p>Output</p> <p><pre><code>Graph(number_of_nodes=0, number_of_edges=0, number_of_temporal_edges=0, earliest_time=None, latest_time=None)\n</code></pre> </p>"},{"location":"user-guide/ingestion/2_direct-updates/","title":"Direct Updates","text":"<p>Now that we have a graph we can directly update it with the <code>add_node()</code> and <code>add_edge()</code> functions.</p>"},{"location":"user-guide/ingestion/2_direct-updates/#adding-nodes","title":"Adding nodes","text":"<p>To add a node we need a unique <code>id</code> to represent it and an update <code>timestamp</code> to specify when in the history of your data this node addition took place. In the below example we are going to add node <code>10</code> at timestamp <code>1</code>. </p> <p>Info</p> <p>If your data doesn't have any timestamps, don't fret! You can just set a constant value like <code>1</code> for all additions into the graph.  </p>  Python <pre><code>from raphtory import Graph\n\ng = Graph()\nv = g.add_node(timestamp=1, id=10)\n\nprint(g)\nprint(v)\n</code></pre> <p>Output</p> <p><pre><code>Graph(number_of_nodes=1, number_of_edges=0, number_of_temporal_edges=0, earliest_time=1, latest_time=1)\nNode(name=10, earliest_time=1, latest_time=1)\n</code></pre> </p> <p>Printing out the graph and the returned node we can see the update was successful and the earliest/latest time has been updated.</p>"},{"location":"user-guide/ingestion/2_direct-updates/#adding-edges","title":"Adding edges","text":"<p>All graphs in raphtory are directed, meaning edge additions must specify a <code>timestamp</code> (the same as a <code>node_add()</code>), the <code>source</code> node the edge starts from and the <code>destination</code> node the edge ends at. </p> <p>As an example of this below we are adding an edge to the graph from <code>15</code> to <code>16</code> at timestamp <code>1</code>.</p> <p>Info</p> <p>You will notice in the output that the graph says that it has two nodes as well as the edge. This is because Raphtory automatically creates the source and destination nodes at the same time if they are yet to exist in the graph. This is to keep the graph consistent and avoid <code>hanging edges</code>.</p>  Python <pre><code>from raphtory import Graph\n\ng = Graph()\ne = g.add_edge(timestamp=1, src=15, dst=16)\n\nprint(g)\nprint(e)\n</code></pre> <p>Output</p> <p><pre><code>Graph(number_of_nodes=2, number_of_edges=1, number_of_temporal_edges=1, earliest_time=1, latest_time=1)\nEdge(source=15, target=16, earliest_time=1, latest_time=1, layer(s)=[_default])\n</code></pre> </p>"},{"location":"user-guide/ingestion/2_direct-updates/#accepted-id-types","title":"Accepted ID types","text":"<p>The data you want to use for node IDs may not always be integers, they can often be unique strings like a person's username or a blockchain wallet hash. As such <code>add_node()</code> and <code>add_edge()</code> will also accept strings for their <code>id</code>, <code>src</code> &amp; <code>dst</code> arguments. </p> <p>Below you can see we are adding two nodes to the graph <code>User 1</code> and <code>User 2</code> and an edge between them. </p>  Python <pre><code>from raphtory import Graph\n\ng = Graph()\n\ng.add_node(timestamp=123, id=\"User 1\")\ng.add_node(timestamp=456, id=\"User 2\")\ng.add_edge(timestamp=789, src=\"User 1\", dst=\"User 2\")\n\nprint(g.node(\"User 1\"))\nprint(g.node(\"User 2\"))\nprint(g.edge(\"User 1\", \"User 2\"))\n</code></pre> <p>Output</p> <p><pre><code>Node(name=User 1, earliest_time=123, latest_time=789)\nNode(name=User 2, earliest_time=456, latest_time=789)\nEdge(source=User 1, target=User 2, earliest_time=789, latest_time=789, layer(s)=[_default])\n</code></pre> </p> <p>Warning</p> <p>Note: A graph can index nodes by either integers or strings, not both at the same time.This means, for example, you cannot have <code>User 1</code> (a string) and <code>200</code> (an integer) as ids in the same graph. </p>"},{"location":"user-guide/ingestion/2_direct-updates/#accepted-timestamps","title":"Accepted timestamps","text":"<p>While integer based timestamps (like in the above examples) can represent both logical time and epoch time, datasets can often have their timestamps stored in human readable formats or special datetime objects. As such, <code>add_node()</code> and <code>add_edge()</code> can accept integers, datetime strings and datetime objects interchangeably. </p> <p>Below we can see node <code>10</code> being added into the graph at <code>2021-02-03 14:01:00</code> and <code>2021-01-01 12:32:00</code>. The first timestamp is kept as a string, with Raphtory internally handling the conversion, and the second has been converted into a python datetime object before ingestion. This datetime object can also have a timezone, with Raphtory storing everything internally in UTC.</p>  Python <pre><code>from raphtory import Graph\nfrom datetime import datetime\n\ng = Graph()\ng.add_node(timestamp=\"2021-02-03 14:01:00\", id=10)\n\n# Create a python datetime object\ndatetime_obj = datetime(2021, 1, 1, 12, 32, 0, 0)\ng.add_node(timestamp=datetime_obj, id=10)\n\nprint(g)\nprint(g.node(id=10).history())\nprint(g.node(id=10).history_date_time())\n</code></pre> <p>Output</p> <p><pre><code>Graph(number_of_nodes=1, number_of_edges=0, number_of_temporal_edges=0, earliest_time=1609504320000, latest_time=1612360860000)\n[1609504320000 1612360860000]\n[datetime.datetime(2021, 1, 1, 12, 32, tzinfo=datetime.timezone.utc), datetime.datetime(2021, 2, 3, 14, 1, tzinfo=datetime.timezone.utc)]\n</code></pre> </p> <p>In our output we can see the <code>history</code> of node <code>10</code> contains the two times at which we have added it into the graph (maintained in ascending order), returned in both unix epoch (integer) and datetime format.</p>"},{"location":"user-guide/ingestion/2_direct-updates/#properties","title":"Properties","text":"<p>Alongside the structural update history, Raphtory can maintain the changing value of properties associated with nodes and edges. Both the <code>add_node()</code> and <code>add_edge()</code> functions have an optional parameter <code>properties</code> which takes a dictionary of key value pairs to be stored at the given timestamp. </p> <p>The graph itself may also have its own <code>global properties</code> via the <code>add_properties()</code> function which takes only a <code>timestamp</code> and a <code>properties</code> dictionary. </p> <p>Properties can consist of primitives (<code>Integer</code>, <code>Float</code>, <code>String</code>, <code>Boolean</code>, <code>Datetime</code>) and structures (<code>Dictionary</code>, <code>List</code>). This allows you to store both basic values as well as do complex hierarchical modelling depending on your use case.</p> <p>In the example below we are using all of these functions to add a mixture of properties to a node, an edge and the graph.</p> <p>Warning</p> <p>Please note that once a <code>property key</code> is associated to one of the above types for a given node/edge/graph, attempting to add a value of a different type under the same key will result in an error. For <code>Lists</code> the values must all be the same type and for <code>Dictionaries</code> the values for each key must always be the same type.</p>  Python <pre><code>from raphtory import Graph\nfrom datetime import datetime\n\ng = Graph()\n\n# Primitive type properties added to a node\ng.add_node(\n    timestamp=1,\n    id=\"User 1\",\n    properties={\"count\": 1, \"greeting\": \"hi\", \"encrypted\": True},\n)\ng.add_node(\n    timestamp=2,\n    id=\"User 1\",\n    properties={\"count\": 2, \"balance\": 0.6, \"encrypted\": False},\n)\ng.add_node(\n    timestamp=3,\n    id=\"User 1\",\n    properties={\"balance\": 0.9, \"greeting\": \"hello\", \"encrypted\": True},\n)\n\n# Dictionaries and Lists added to a graph\ng.add_properties(\n    timestamp=1,\n    properties={\n        \"inner data\": {\"name\": \"bob\", \"value list\": [1, 2, 3]},\n        \"favourite greetings\": [\"hi\", \"hello\", \"howdy\"],\n    },\n)\ndatetime_obj = datetime.strptime(\"2021-01-01 12:32:00\", \"%Y-%m-%d %H:%M:%S\")\ng.add_properties(\n    timestamp=2,\n    properties={\n        \"inner data\": {\n            \"date of birth\": datetime_obj,\n            \"fruits\": {\"apple\": 5, \"banana\": 3},\n        }\n    },\n)\n\n# Weight list on an edge\ng.add_edge(timestamp=4, src=\"User 1\", dst=\"User 2\", properties={\"weights\": [1,2,3]})\n\n# Printing everything out\nv = g.node(id=\"User 1\")\ne = g.edge(src=\"User 1\", dst=\"User 2\")\nprint(g)\nprint(v)\nprint(e)\n</code></pre> <p>Output</p> <p><pre><code>Graph(number_of_nodes=2, number_of_edges=1, number_of_temporal_edges=1, earliest_time=1, latest_time=4, properties=Properties({inner data: {fruits: {apple: 5, banana: 3}, date of birth: 2021-01-01 12:32:00}, favourite greetings: [hi, hello, howdy]}))\nNode(name=User 1, earliest_time=1, latest_time=4, properties=Properties({count: 2, greeting: hello, encrypted: true, balance: 0.9}))\nEdge(source=User 1, target=User 2, earliest_time=4, latest_time=4, properties={weights: [1, 2, 3]}, layer(s)=[_default])\n</code></pre> </p> <p>Info</p> <p>You will see in the output that when we print these, only the latest values are shown. The older values haven't been lost, in fact the history of all of these different property types can be queried, explored and aggregated, as you will see in Property Queries.</p>"},{"location":"user-guide/ingestion/2_direct-updates/#constant-properties","title":"Constant Properties","text":"<p>Alongside the <code>temporal</code> properties which have a value history, Raphtory also provides <code>constant</code> properties which have an immutable value. These are useful when you know a value won't change or are adding <code>meta data</code> to your graph which doesn't make sense to happen at a specific time in the given context. To add these into your model the <code>graph</code>, <code>node</code> and <code>edge</code> have the <code>add_constant_properties()</code> function, which takes a single properties dict argument.</p> <p>You can see in the example below three different constant properties being added to the <code>graph</code>, <code>node</code> and <code>edge</code>. </p>  Python <pre><code>from raphtory import Graph\nfrom datetime import datetime\n\ng = Graph()\nv = g.add_node(timestamp=1, id=\"User 1\")\ne = g.add_edge(timestamp=2, src=\"User 1\", dst=\"User 2\")\n\ng.add_constant_properties(properties={\"name\": \"Example Graph\"})\nv.add_constant_properties(\n    properties={\"date of birth\": datetime.strptime(\"1990-02-03\", \"%Y-%m-%d\")},\n)\ne.add_constant_properties(properties={\"data source\": \"https://link-to-repo.com\"})\n\nprint(g)\nprint(v)\nprint(e)\n</code></pre> <pre><code>Graph(number_of_nodes=2, number_of_edges=1, number_of_temporal_edges=1, earliest_time=1, latest_time=2, properties=Properties({name: Example Graph}))\nNode(name=User 1, earliest_time=1, latest_time=2, properties=Properties({date of birth: 1990-02-03 00:00:00}))\nEdge(source=User 1, target=User 2, earliest_time=2, latest_time=2, properties={data source: https://link-to-repo.com}, layer(s)=[_default])\n</code></pre>"},{"location":"user-guide/ingestion/2_direct-updates/#edge-layers","title":"Edge Layers","text":"<p>If you have worked with other graph libraries you may be expecting two calls to <code>add_edge()</code> between the same nodes to generate two distinct edge objects. As we have seen above, in Raphtory, these calls will append the information together into the history of a single edge. </p> <p>These edges can be <code>exploded</code> to interact with all updates independently (as you shall see in Exploded edges), but Raphtory also allows you to represent totally different relationships between the same nodes via <code>edge layers</code>.</p> <p>The <code>add_edge()</code> function takes a second optional parameter, <code>layer</code>, allowing the user to name the type of relationship being added. All calls to <code>add_edge</code> with the same <code>layer</code> value will be stored together allowing them to be accessed separately or merged with other layers as required.</p> <p>You can see this in the example below where we add five updates between <code>Person 1</code> and <code>Person 2</code> across the layers <code>Friends</code>, <code>Co Workers</code> and <code>Family</code>. When we query the history of the <code>weight</code> property on the edge we initially get all of the values back. However, after applying the <code>layers()</code> graph view we only return updates from <code>Co Workers</code> and <code>Family</code>. </p>  Python <pre><code>from raphtory import Graph\n\ng = Graph()\ng.add_edge(\n    timestamp=1,\n    src=\"Person 1\",\n    dst=\"Person 2\",\n    properties={\"weight\": 10},\n    layer=\"Friends\",\n)\ng.add_edge(\n    timestamp=2,\n    src=\"Person 1\",\n    dst=\"Person 2\",\n    properties={\"weight\": 13},\n    layer=\"Friends\",\n)\ng.add_edge(\n    timestamp=3,\n    src=\"Person 1\",\n    dst=\"Person 2\",\n    properties={\"weight\": 20},\n    layer=\"Co Workers\",\n)\ng.add_edge(\n    timestamp=4,\n    src=\"Person 1\",\n    dst=\"Person 2\",\n    properties={\"weight\": 17},\n    layer=\"Friends\",\n)\ng.add_edge(\n    timestamp=5,\n    src=\"Person 1\",\n    dst=\"Person 2\",\n    properties={\"weight\": 35},\n    layer=\"Family\",\n)\n\nunlayered_edge = g.edge(\"Person 1\", \"Person 2\")\nlayered_edge = g.layers([\"Co Workers\", \"Family\"]).edge(\"Person 1\", \"Person 2\")\nprint(unlayered_edge.properties.temporal.get(\"weight\").values())\nprint(layered_edge.properties.temporal.get(\"weight\").values())\n</code></pre> <p>Output</p> <p><pre><code>[10 13 20 17 35]\n[20 35]\n</code></pre> </p>"},{"location":"user-guide/ingestion/3_dataframes/","title":"Ingesting from dataframes","text":"<p>If you prefer to initially manipulate your data in a <code>dataframe</code> before converting into a graph, Raphtory can directly ingest dataframes, converting these into node and edge updates. </p>"},{"location":"user-guide/ingestion/3_dataframes/#creating-a-graph-from-dataframes","title":"Creating a graph from dataframes","text":"<p>In the example below we are ingesting some network traffic data which includes different types of interactions between servers. In this first half of the code we read the data from disk into two dataframes, one for the server information (nodes) and one for the server interactions (edges). We then convert the timestamp column to datetime objects. Finally, the two dataframes are printed out so you can see the headers and values.</p>  Python <pre><code>from raphtory import Graph\nimport pandas as pd\n\nedges_df = pd.read_csv(\"data/network_traffic_edges.csv\")\nedges_df[\"timestamp\"] = pd.to_datetime(edges_df[\"timestamp\"])\n\nnodes_df = pd.read_csv(\"data/network_traffic_nodes.csv\")\nnodes_df[\"timestamp\"] = pd.to_datetime(nodes_df[\"timestamp\"])\n\npd.set_option('display.max_columns', None)  # so all columns are printed\nprint(\"--- Edge Dataframe ---\")\nprint(f\"{edges_df.head(2)}\\n\")\nprint()\nprint(\"--- Node Dataframe ---\")\nprint(f\"{nodes_df.head(2)}\\n\")\n</code></pre> <p>Output</p> <p><pre><code>--- Edge Dataframe ---\n                  timestamp   source destination  data_size_MB  \\\n0 2023-09-01 08:00:00+00:00  ServerA     ServerB           5.6   \n1 2023-09-01 08:05:00+00:00  ServerA     ServerC           7.1   \n\n          transaction_type  is_encrypted  \n0  Critical System Request          True  \n1            File Transfer         False  \n\n\n--- Node Dataframe ---\n                  timestamp server_id server_name hardware_type    OS_version  \\\n0 2023-09-01 08:00:00+00:00   ServerA       Alpha  Blade Server  Ubuntu 20.04   \n1 2023-09-01 08:05:00+00:00   ServerB        Beta   Rack Server   Red Hat 8.1   \n\n  primary_function  uptime_days  \n0         Database          120  \n1       Web Server           45  \n</code></pre> </p> <p>Next, to ingest these dataframes into Raphtory, we will use the <code>load_edges_from_pandas()</code> and <code>load_nodes_from_pandas()</code> functions.  These functions has optional arguments to cover everything we have seen in the prior direct updates tutorial. </p> <p>For the call to <code>load_edges_from_pandas()</code> we specify:</p> <ul> <li>The dataframe we are ingesting (<code>edges_df</code>).</li> <li>The source, destination and time columns within the dataframe (<code>source</code>,<code>destination</code>,<code>timestamp</code>).</li> <li>The temporal properties (<code>data_size_MB</code>), constant properties (<code>is_encrypted</code>), and the layer column (<code>transaction_type</code>) .</li> <li>An additional shared constant property (<code>datasource</code>), which will be added to all edges, specifying where these edges come from. </li> </ul> <p>This is followed by the parameters for the nodes, consisting of:</p> <ul> <li>The dataframe we are ingesting (<code>nodes_df</code>).</li> <li>The node ID and time columns (<code>server_id</code>,<code>timestamp</code>).</li> <li>The temporal properties (<code>OS_version</code>,<code>primary_function</code>,<code>uptime_days</code>) and constant properties (<code>server_name</code>,<code>hardware_type</code>).</li> <li>A shared constant property labelling the source of this information (<code>datasource</code>).</li> </ul> <p>The resulting graph and an example node/edge are then printed to show the data fully converted.</p>  Python <pre><code>g = Graph()\ng.load_edges_from_pandas(\n    df=edges_df,\n    time=\"timestamp\",\n    src=\"source\",\n    dst=\"destination\",\n    properties=[\"data_size_MB\"],\n    layer_col=\"transaction_type\",\n    constant_properties=[\"is_encrypted\"],\n    shared_constant_properties={\"datasource\": \"data/network_traffic_edges.csv\"},\n)\ng.load_nodes_from_pandas(\n    df=nodes_df,\n    time=\"timestamp\",\n    id=\"server_id\",\n    properties=[\"OS_version\", \"primary_function\", \"uptime_days\"],\n    constant_properties=[\"server_name\", \"hardware_type\"],\n    shared_constant_properties={\"datasource\": \"data/network_traffic_edges.csv\"},\n\n)\n\nprint(\"The resulting graphs and example node/edge:\")\nprint(g)\nprint(g.node(\"ServerA\"))\nprint(g.edge(\"ServerA\", \"ServerB\"))\n</code></pre> <p>Output</p> <p><pre><code>The resulting graphs and example node/edge:\nGraph(number_of_nodes=5, number_of_edges=7, number_of_temporal_edges=7, earliest_time=1693555200000, latest_time=1693557000000)\nNode(name=ServerA, earliest_time=1693555200000, latest_time=1693556400000, properties=Properties({OS_version: Ubuntu 20.04, primary_function: Database, uptime_days: 120, datasource: data/network_traffic_edges.csv, server_name: Alpha, hardware_type: Blade Server}))\nEdge(source=ServerA, target=ServerB, earliest_time=1693555200000, latest_time=1693555200000, properties={data_size_MB: 5.6, datasource: {Critical System Request: data/network_traffic_edges.csv}, is_encrypted: {Critical System Request: true}}, layer(s)=[Critical System Request])\n</code></pre> </p>"},{"location":"user-guide/ingestion/3_dataframes/#adding-constant-properties-via-dataframes","title":"Adding constant properties via dataframes","text":"<p>As with the direct updates, there may be instances where you are adding a dataset which has no timestamps within it. To handle this when ingesting via dataframes the graph has the <code>load_edge_props_from_pandas()</code> and <code>load_node_props_from_pandas()</code> functions.</p> <p>Below we break the ingestion into a four stage process, adding the constant properties at the end. We make use of the same two dataframes for brevity of the example, but in real instances these would probably be four different dataframes, one for each function call.</p> <p>Warning</p> <p>Constant properties can only be added to nodes and edges which are part of the graph. If you attempt to add a constant property without first adding the node/edge an error will be thrown.</p>  Python <pre><code>g = Graph()\ng.load_edges_from_pandas(\n    df=edges_df,\n    src=\"source\",\n    dst=\"destination\",\n    time=\"timestamp\",\n    properties=[\"data_size_MB\"],\n    layer_col=\"transaction_type\",\n)\n\ng.load_nodes_from_pandas(\n    df=nodes_df,\n    id=\"server_id\",\n    time=\"timestamp\",\n    properties=[\"OS_version\", \"primary_function\", \"uptime_days\"],\n)\n\ng.load_edge_props_from_pandas(\n    df=edges_df,\n    src=\"source\",\n    dst=\"destination\",\n    layer_col=\"transaction_type\",\n    constant_properties=[\"is_encrypted\"],\n    shared_constant_properties={\"datasource\": \"data/network_traffic_edges.csv\"},\n)\n\ng.load_node_props_from_pandas(\n    df=nodes_df,\n    id=\"server_id\",\n    constant_properties=[\"server_name\", \"hardware_type\"],\n    shared_constant_properties={\"datasource\": \"data/network_traffic_edges.csv\"},\n)\n\nprint(g)\nprint(g.node(\"ServerA\"))\nprint(g.edge(\"ServerA\", \"ServerB\"))\n</code></pre> <p>Output</p> <p><pre><code>Graph(number_of_nodes=5, number_of_edges=7, number_of_temporal_edges=7, earliest_time=1693555200000, latest_time=1693557000000)\nNode(name=ServerA, earliest_time=1693555200000, latest_time=1693556400000, properties=Properties({OS_version: Ubuntu 20.04, primary_function: Database, uptime_days: 120, datasource: data/network_traffic_edges.csv, server_name: Alpha, hardware_type: Blade Server}))\nEdge(source=ServerA, target=ServerB, earliest_time=1693555200000, latest_time=1693555200000, properties={data_size_MB: 5.6, datasource: {Critical System Request: data/network_traffic_edges.csv}, is_encrypted: {Critical System Request: true}}, layer(s)=[Critical System Request])\n</code></pre> </p>"},{"location":"user-guide/ingestion/4_saving/","title":"Saving and loading graphs","text":"<p>The fastest way to ingest a graph is to load one from Raphtory's on-disk format using the <code>load_from_file()</code> function on the graph. This does require first ingesting via one of the prior methods and saving the produced graph via <code>save_to_file()</code> or <code>save_to_zip()</code>, but means for large datasets you do not need to parse the data every time you run a Raphtory script.</p> <p>Info</p> <p>You can also pickle Raphtory graphs, which uses these functions under the hood.</p> <p>In the example below we ingest the edge dataframe from the last section, save this graph and reload it into a second graph. These are both printed to show they contain the same data.</p>  Python <pre><code>from raphtory import Graph\nimport pandas as pd\n\nedges_df = pd.read_csv(\"data/network_traffic_edges.csv\")\nedges_df[\"timestamp\"] = pd.to_datetime(edges_df[\"timestamp\"])\n\ng = Graph()\ng.load_edges_from_pandas(\n    df=edges_df,\n    time=\"timestamp\",\n    src=\"source\",\n    dst=\"destination\",\n    properties=[\"data_size_MB\"],\n    layer_col=\"transaction_type\",\n)\ng.save_to_file(\"/tmp/saved_graph\") \nloaded_graph = Graph.load_from_file(\"/tmp/saved_graph\")\nprint(g)\nprint(loaded_graph)\n</code></pre> <p>Output</p> <p><pre><code>Graph(number_of_nodes=5, number_of_edges=7, number_of_temporal_edges=7, earliest_time=1693555200000, latest_time=1693557000000)\nGraph(number_of_nodes=5, number_of_edges=7, number_of_temporal_edges=7, earliest_time=1693555200000, latest_time=1693557000000)\n</code></pre> </p>"},{"location":"user-guide/persistent-graph/1_intro/","title":"Graph and persistent graph","text":"<p>Up to now, we have made an implicit assumption that a temporal graph is made up of events (messages, citations, transactions) instantiated from one node to another that can be thought of as instantaneous. In the temporal graph literature, such representations of graphs are known as link streams. This representation can also capture temporal graphs that can be considered a sequence of static network snapshots (by giving edges integer timestamps 1, 2, 3, ... depending on the snapshot(s) in which they are found.)</p> <p>However, there is another family of temporal graphs which don't fit into this format. What about instead of an instantaneous event, edges could be present for a defined amount of time? Such occasions might include proximity networks where an edge between two individuals is continuously present whenever they are close together, or a 'following' network where edges are established and later potentially removed. To enable these types of interactions to be represented, we provide an additional graph representation where edges can be added, removed and added back again called the <code>PersistentGraph</code>. Let's have a look at how we create and manipulate such a graph.</p>  Python <p> <code>Graph</code> <pre><code>from raphtory import PersistentGraph\n\nG = PersistentGraph()\n\n# new friendship\nG.add_edge(1, \"Alice\", \"Bob\")\n\n# additional friend\nG.add_edge(3, \"Bob\", \"Charlie\")\n\n# a dispute\nG.delete_edge(5, \"Alice\", \"Bob\")\n\n# a resolution\nG.add_edge(10, \"Alice\", \"Bob\")\n\nprint(f\"G's edges are {G.edges}\")\nprint(f\"G's exploded edges are {G.edges.explode()}\")\n</code></pre></p> <p>Output</p> <p><pre><code>G's edges are Edges(Edge(source=Alice, target=Bob, earliest_time=1, latest_time=9223372036854775807, layer(s)=[_default]), Edge(source=Bob, target=Charlie, earliest_time=3, latest_time=9223372036854775807, layer(s)=[_default]))\nG's exploded edges are Edges(Edge(source=Alice, target=Bob, earliest_time=1, latest_time=5, layer(s)=[_default]), Edge(source=Alice, target=Bob, earliest_time=10, latest_time=9223372036854775807, layer(s)=[_default]), Edge(source=Bob, target=Charlie, earliest_time=3, latest_time=9223372036854775807, layer(s)=[_default]))\n</code></pre> </p> <p>Here we have a graph with two edges: one connecting Alice and Bob, and one connecting Bob and Charlie, and three exploded edges, one for each activation of Alice and Bob's edge and the activation of Bob and Charlie's edge. Note that if an edge is not explicitly deleted, it is assumed to last forever (or at least until int max value...)</p> <p>Over the next few pages, we will explore how the persistent graph works to understand its behaviour/semantics and how it can unlock some interesting analysis.</p>"},{"location":"user-guide/persistent-graph/2_ambiguity/","title":"Handling of ambiguous updates","text":"<p>Whereas there is a natural way to construct a link-stream graph regardless of the order the updates come in, throwing deletions into the mix can lead to questions about what graph to create. Let's look at the below example. </p>"},{"location":"user-guide/persistent-graph/2_ambiguity/#order-of-resolving-additions-and-deletions","title":"Order of resolving additions and deletions","text":"Python <p> <code>Graph</code> <pre><code>G = PersistentGraph()\n\nG.add_edge(1, \"Alice\", \"Bob\")\nG.delete_edge(5, \"Alice\", \"Bob\")\nG.add_edge(3, \"Alice\", \"Bob\")\nG.delete_edge(7, \"Alice\", \"Bob\")\n\nprint(G.edges.explode())\n</code></pre></p> <p>Reading this line by line, we may see this as two edges between Alice and Bob which overlap in time: one starting at time 1 and ending at time 5, another starting at time 3 and ending at time 7. After all, the link-stream graphs in Raphtory are allowed to have edges between the same pair of nodes happening at the same instant. However, when we look at the exploded edges of this graph, the following is returned:</p> <p>Output</p> <p><pre><code>Edges(Edge(source=Alice, target=Bob, earliest_time=1, latest_time=3, layer(s)=[_default]), Edge(source=Alice, target=Bob, earliest_time=3, latest_time=5, layer(s)=[_default]))\n</code></pre> </p> <p>Here, we see two edges which are contingent to each other in time: one from time 1 to time 3 and one from time 3 to time 5. The second deletion at time 7 is ignored. The reason for this is that Raphtory's graph updates are inserted in chronological order, such that the same graph should be constructed regardless of the line order in which the updates are made (apart from events which have the same timestamp, which will be covered shortly). Here, the order is: edge addition at time 1, edge addition at time 3, edge deletion at time 5 and edge deletion at time 7. This second edge deletion is now redundant.</p>"},{"location":"user-guide/persistent-graph/2_ambiguity/#hanging-deletions","title":"Hanging deletions","text":"<p>We saw on the previous page that adding edges without a deletion afterwards results in an edge which lasts forever. What about a deletion without a prior addition?</p>  Python <p> <code>Graph</code> <pre><code>G = PersistentGraph()\n\nG.delete_edge(5, \"Alice\", \"Bob\")\n\nprint(G.edges.explode())\n</code></pre></p> <p>This results in the following:</p> <p>Output</p> <p><pre><code>Edges()\n</code></pre> </p> <p>which assumes that an edge was once present for it to be deleted. This can be useful if we have a dataset of changes to a graph but we're missing some starting period of the system which would have once included some original edge additions.</p>"},{"location":"user-guide/persistent-graph/2_ambiguity/#additions-and-deletions-in-the-same-instant","title":"Additions and deletions in the same instant","text":"<p>We have seen that if the update times to an edge are all distinct from each other, the graph that is constructed is fully unambiguous. What about when events have the same timestamp? </p>  Python <p> <code>Graph</code> <pre><code>G1 = PersistentGraph()\n\nG1.add_edge(1, 1, 2, properties={\"message\":\"hi\"})\nG1.delete_edge(1, 1, 2)\n\nG2 = PersistentGraph()\n\nG2.delete_edge(1, 1, 2)\nG2.add_edge(1, 1, 2, properties={\"message\":\"hi\"})\n\nprint(f\"G1's edges are {G1.edges.explode()}\")\nprint(f\"G2's edges are {G2.edges.explode()}\")\n</code></pre></p> <p>Output</p> <p><pre><code>G1's edges are Edges(Edge(source=1, target=2, earliest_time=1, latest_time=1, properties={message: hi}, layer(s)=[_default]))\nG2's edges are Edges(Edge(source=1, target=2, earliest_time=1, latest_time=9223372036854775807, properties={message: hi}, layer(s)=[_default]))\n</code></pre> </p> <p>In this example, it is impossible to infer what the intended update order is (particularly since we allow hanging deletions/additions). In this case, we tie-break the updates by the order in which they are executed. This means that the first graph has an edge which instantaneously appears and disappears at time 1, and in the second an edge which instantaneously disappears at time 1 but is present for all time before and all after. It is important to bear this in mind in your analysis if you are aware of some cases like this.</p>"},{"location":"user-guide/persistent-graph/2_ambiguity/#interaction-with-layers","title":"Interaction with layers","text":"<p>Remember the example earlier with how deletions and additions are resolved?</p>  Python <p> <code>Graph</code> <pre><code>G = PersistentGraph()\n\nG.add_edge(1, \"Alice\", \"Bob\")\nG.delete_edge(5, \"Alice\", \"Bob\")\nG.add_edge(3, \"Alice\", \"Bob\")\nG.delete_edge(7, \"Alice\", \"Bob\")\n\nprint(G.edges.explode())\n</code></pre></p> <p>Output</p> <p><pre><code>Edges(Edge(source=Alice, target=Bob, earliest_time=1, latest_time=3, layer(s)=[_default]), Edge(source=Alice, target=Bob, earliest_time=3, latest_time=5, layer(s)=[_default]))\n</code></pre> </p> <p>Now take a look at this slightly modified example.</p>  Python <p> <code>Graph</code> <pre><code>G = PersistentGraph()\n\nG.add_edge(1, \"Alice\", \"Bob\", layer=\"colleagues\")\nG.delete_edge(5, \"Alice\", \"Bob\", layer=\"colleagues\")\nG.add_edge(3, \"Alice\", \"Bob\", layer =\"friends\")\nG.delete_edge(7, \"Alice\", \"Bob\", layer=\"friends\")\n\nprint(G.edges.explode())\n</code></pre></p> <p>The only difference is that we've added layer names to the different edge instances. Now let's look at how the output differs.</p> <p>Output</p> <p><pre><code>Edges(Edge(source=Alice, target=Bob, earliest_time=1, latest_time=5, layer(s)=[colleagues]), Edge(source=Alice, target=Bob, earliest_time=3, latest_time=7, layer(s)=[friends]))\n</code></pre> </p> <p>Here we have two edges, one starting and ending at 1 and 5 respectively with the 'colleague' layer, the other starting and ending at 3 and 7 on the 'friends' layer. Layering allows different types of interaction to exist, and edges on different layers can have overlapping times in a way that doesn't make sense for edges in the same layer or for edges with no layer. </p>"},{"location":"user-guide/persistent-graph/3_views/","title":"Views on a persistent graph","text":"<p>When dealing with the <code>Graph</code> object previously where edges are formed from instantaneous event streams, views were used to create a temporal bound on the graph to ultimately see how the graph changes over time. Single views were created using <code>at</code>, <code>before</code>, <code>after</code> and <code>window</code>, and iterators of windows were created using <code>expanding</code> and <code>rolling</code>. Functionality with the same name is available for the persistent graph. It shares similarities with the functionality for <code>Graph</code> but has some important differences. Through the use of example, this page aims to cover the behaviour of this time-bounding behaviour on the <code>PersistentGraph</code>.</p>"},{"location":"user-guide/persistent-graph/3_views/#querying-an-instant-of-the-graph-with-at","title":"Querying an instant of the graph with <code>at()</code>","text":"Python <p> <code>Graph</code> <pre><code>G = PersistentGraph()\n\nG.add_edge(2, \"Alice\", \"Bob\")\nG.delete_edge(5, \"Alice\", \"Bob\")\n\n# before the edge is added\nprint(f\"At time 0: {G.at(0).nodes} {G.at(0).edges.explode()}\")\n\n# at the instant the edge is added\nprint(f\"At time 2: {G.at(2).nodes} {G.at(2).edges.explode()}\")\n\n# while the graph is active\nprint(f\"At time 3: {G.at(3).nodes} {G.at(3).edges.explode()}\")\n\n# the instant the edge is deleted\nprint(f\"At time 5: {G.at(5).nodes} {G.at(5).edges.explode()}\")\n\n# after the edge is deleted\nprint(f\"At time 6: {G.at(6).nodes} {G.at(6).edges.explode()}\")\n</code></pre></p> <p>Output</p> <p><pre><code>At time 0: Nodes() Edges()\nAt time 2: Nodes(Node(name=Alice, earliest_time=2, latest_time=2), Node(name=Bob, earliest_time=2, latest_time=2)) Edges(Edge(source=Alice, target=Bob, earliest_time=2, latest_time=2, layer(s)=[_default]))\nAt time 3: Nodes(Node(name=Alice, earliest_time=3, latest_time=3), Node(name=Bob, earliest_time=3, latest_time=3)) Edges(Edge(source=Alice, target=Bob, earliest_time=3, latest_time=3, layer(s)=[_default]))\nAt time 5: Nodes(Node(name=Alice, earliest_time=5, latest_time=5), Node(name=Bob, earliest_time=5, latest_time=5)) Edges()\nAt time 6: Nodes(Node(name=Alice, earliest_time=6, latest_time=6), Node(name=Bob, earliest_time=6, latest_time=6)) Edges()\n</code></pre> </p> <p>As we can see, the edge's presence in the graph is inclusive of the timestamp at which it was added, but exclusive of the timestamp at which it was deleted. You might think of it being present on a interval \\(1 \\leq t &lt; 5 \\subseteq \\mathbb{Z}\\). Note that the earliest and latest times for each edge is adjusted to the time bound in the query.</p> <p>Another thing to note is that while nodes are not present until they are added (see example at time 1), but once they are added they are in the graph forever (see example at time 6). This differs from the <code>Graph</code> equivalent where nodes are present only when they contain an update within the time bounds. Crucially, this means that while performing a node count on a <code>Graph</code> will count the nodes who have activity (a property update, an adjacent edge added) within the time bounds specified, the same is not true for <code>PersistentGraph</code>s. As this may not be desirable, we are currently working on an alternative in which nodes without any edge within the time window will be treated as not present.</p>"},{"location":"user-guide/persistent-graph/3_views/#getting-the-graph-before-a-certain-point-with-before","title":"Getting the graph before a certain point with <code>before()</code>","text":"Python <p> <code>Graph</code> <pre><code>G = PersistentGraph()\n\nG.add_edge(2, \"Alice\", \"Bob\")\nG.delete_edge(5, \"Alice\", \"Bob\")\n\n# before the edge is added\nprint(f\"Before time 1: {G.before(1).nodes} {G.before(1).edges.explode()}\")\n\n# at the instant the edge is added\nprint(f\"Before time 2: {G.before(2).nodes} {G.before(2).edges.explode()}\")\n\n# while the graph is active\nprint(f\"Before time 3: {G.before(3).nodes} {G.before(3).edges.explode()}\")\n\n# the instant the edge is deleted\nprint(f\"Before time 5: {G.before(5).nodes} {G.before(5).edges.explode()}\")\n\n# after the edge is deleted\nprint(f\"Before time 6: {G.before(6).nodes} {G.before(6).edges.explode()}\")\n</code></pre></p> <p>Output</p> <p><pre><code>Before time 1: Nodes() Edges()\nBefore time 2: Nodes() Edges()\nBefore time 3: Nodes(Node(name=Alice, earliest_time=2, latest_time=2), Node(name=Bob, earliest_time=2, latest_time=2)) Edges(Edge(source=Alice, target=Bob, earliest_time=2, latest_time=2, layer(s)=[_default]))\nBefore time 5: Nodes(Node(name=Alice, earliest_time=2, latest_time=4), Node(name=Bob, earliest_time=2, latest_time=4)) Edges(Edge(source=Alice, target=Bob, earliest_time=2, latest_time=4, layer(s)=[_default]))\nBefore time 6: Nodes(Node(name=Alice, earliest_time=2, latest_time=5), Node(name=Bob, earliest_time=2, latest_time=5)) Edges(Edge(source=Alice, target=Bob, earliest_time=2, latest_time=5, layer(s)=[_default]))\n</code></pre> </p> <p>Here we see that the <code>before(T)</code> bound is exclusive of the end point \\(T\\), creating an intersection between the time interval \\(-\\infty &lt; t &lt; T\\) and \\(2 \\leq t &lt; 5\\) where \\(T\\) is the argument of <code>before</code>.</p>"},{"location":"user-guide/persistent-graph/3_views/#getting-the-graph-after-a-certain-point-with-after","title":"Getting the graph after a certain point with <code>after()</code>","text":"Python <p> <code>Graph</code> <pre><code>G = PersistentGraph()\n\nG.add_edge(2, \"Alice\", \"Bob\")\nG.delete_edge(5, \"Alice\", \"Bob\")\n\n# before the edge is added\nprint(f\"After time 1: {G.after(1).nodes} {G.after(1).edges.explode()}\")\n\n# at the instant the edge is added\nprint(f\"After time 2: {G.after(2).nodes} {G.after(2).edges.explode()}\")\n\n# while the graph is active\nprint(f\"After time 3: {G.after(3).nodes} {G.after(3).edges.explode()}\")\n\n# the instant the edge is deleted\nprint(f\"After time 5: {G.after(5).nodes} {G.after(5).edges.explode()}\")\n\n# after the edge is deleted\nprint(f\"After time 6: {G.after(6).nodes} {G.after(6).edges.explode()}\")\n</code></pre></p> <p>Output</p> <p><pre><code>After time 1: Nodes(Node(name=Alice, earliest_time=2, latest_time=9223372036854775806), Node(name=Bob, earliest_time=2, latest_time=9223372036854775806)) Edges(Edge(source=Alice, target=Bob, earliest_time=2, latest_time=5, layer(s)=[_default]))\nAfter time 2: Nodes(Node(name=Alice, earliest_time=3, latest_time=9223372036854775806), Node(name=Bob, earliest_time=3, latest_time=9223372036854775806)) Edges(Edge(source=Alice, target=Bob, earliest_time=3, latest_time=5, layer(s)=[_default]))\nAfter time 3: Nodes(Node(name=Alice, earliest_time=4, latest_time=9223372036854775806), Node(name=Bob, earliest_time=4, latest_time=9223372036854775806)) Edges(Edge(source=Alice, target=Bob, earliest_time=4, latest_time=5, layer(s)=[_default]))\nAfter time 5: Nodes(Node(name=Alice, earliest_time=6, latest_time=9223372036854775806), Node(name=Bob, earliest_time=6, latest_time=9223372036854775806)) Edges()\nAfter time 6: Nodes(Node(name=Alice, earliest_time=7, latest_time=9223372036854775806), Node(name=Bob, earliest_time=7, latest_time=9223372036854775806)) Edges()\n</code></pre> </p> <p><code>after(T)</code> is also exclusive of the starting point \\(T\\).</p>"},{"location":"user-guide/persistent-graph/3_views/#windowing-the-graph-with-window","title":"Windowing the graph with <code>window()</code>","text":"Python <p> <code>Graph</code> <pre><code>G = PersistentGraph()\n\nG.add_edge(2, \"Alice\", \"Bob\")\nG.delete_edge(5, \"Alice\", \"Bob\")\n\n# Touching the start time of the edge\nprint(f\"Window 0,2: {G.window(0,2).nodes} {G.window(0,2).edges.explode()}\")\n\n# Overlapping the start of the edge\nprint(f\"Window 0,4: {G.window(0,4).nodes} {G.window(0,4).edges.explode()}\")\n\n# Fully inside the edge time\nprint(f\"Window 3,4: {G.window(3,4).nodes} {G.window(3,4).edges.explode()}\")\n\n# Touching the end of the edge\nprint(f\"Window 5,8: {G.window(5,8).nodes} {G.window(5,8).edges.explode()}\")\n\n# Fully containing the edge\nprint(f\"Window 1,8: {G.window(1,8).nodes} {G.window(1,8).edges.explode()}\")\n\n# after the edge is deleted\nprint(f\"Window 6,10: {G.window(6,10).nodes} {G.window(6,10).edges.explode()}\")\n</code></pre></p> <p>Output</p> <p><pre><code>Window 0,2: Nodes() Edges()\nWindow 0,4: Nodes(Node(name=Alice, earliest_time=2, latest_time=3), Node(name=Bob, earliest_time=2, latest_time=3)) Edges(Edge(source=Alice, target=Bob, earliest_time=2, latest_time=3, layer(s)=[_default]))\nWindow 3,4: Nodes(Node(name=Alice, earliest_time=3, latest_time=3), Node(name=Bob, earliest_time=3, latest_time=3)) Edges(Edge(source=Alice, target=Bob, earliest_time=3, latest_time=3, layer(s)=[_default]))\nWindow 5,8: Nodes(Node(name=Alice, earliest_time=5, latest_time=7), Node(name=Bob, earliest_time=5, latest_time=7)) Edges()\nWindow 1,8: Nodes(Node(name=Alice, earliest_time=2, latest_time=7), Node(name=Bob, earliest_time=2, latest_time=7)) Edges(Edge(source=Alice, target=Bob, earliest_time=2, latest_time=5, layer(s)=[_default]))\nWindow 6,10: Nodes(Node(name=Alice, earliest_time=6, latest_time=9), Node(name=Bob, earliest_time=6, latest_time=9)) Edges()\n</code></pre> </p> <p>A <code>window(T1, T2)</code> creates a half-open interval \\(T_1 \\leq t &lt; T_2\\) intersecting the edge's active time ( \\(2 \\leq t &lt; 5 \\) in this case). Some examples to note are when the window is completely inside the edge active time and when the edge's active time is strictly inside the window. In both cases, the edge is treated as present in the graph. For some applications, it may be useful to consider edges whose last update inside the window is a deletion as being absent. This option is going to be explored in coming versions of Raphtory.</p>"},{"location":"user-guide/querying/1_intro/","title":"Introduction and dataset","text":"<p>After reading data into Raphtory we can now make use of the graph representation to ask some interesting questions. For this tutorial, we will use a dataset from SocioPatterns, comprising different behavioural interactions between a group of 22 baboons over a month. </p> <p>Info</p> <p>If you want to read more about the dataset, you can check it out in this paper: V. Gelardi, J. Godard, D. Paleressompoulle, N. Claidi\u00e8re, A. Barrat, \u201cMeasuring social networks in primates: wearable sensors vs. direct observations\u201d, Proc. R. Soc. A 476:20190737 (2020). </p> <p>In the below code we load this dataset into a dataframe and do a small amount of preprocessing to prepare it for loading into Raphtory. This includes dropping rows with blank fields and mapping the values of the <code>behaviour category</code> into a <code>weight</code> which can be aggregated. The mapping consists of the following conversions:</p> <ul> <li>Affiliative (positive interaction) \u2192 <code>+1</code></li> <li>Agonistic (negative interaction) \u2192 <code>-1</code> </li> <li>Other (neutral interaction) \u2192 <code>0</code></li> </ul>  Python <p> <code>Graph</code> <pre><code>import pandas as pd\n\nedges_df = pd.read_csv(\n    \"data/OBS_data.txt\", sep=\"\\t\", header=0, usecols=[0, 1, 2, 3, 4], parse_dates=[0]\n)\nedges_df[\"DateTime\"] = pd.to_datetime(edges_df[\"DateTime\"])\nedges_df.dropna(axis=0, inplace=True)\nedges_df[\"Weight\"] = edges_df[\"Category\"].apply(\n    lambda c: 1 if (c == \"Affiliative\") else (-1 if (c == \"Agonistic\") else 0)\n)\nprint(edges_df.head())\n</code></pre></p> <p>Output</p> <p><pre><code>              DateTime   Actor Recipient  Behavior     Category  Weight\n15 2019-06-13 09:50:00  ANGELE    FELIPE  Grooming  Affiliative       1\n17 2019-06-13 09:50:00  ANGELE    FELIPE  Grooming  Affiliative       1\n19 2019-06-13 09:51:00  FELIPE    ANGELE   Resting  Affiliative       1\n20 2019-06-13 09:51:00  FELIPE      LIPS   Resting  Affiliative       1\n21 2019-06-13 09:51:00  ANGELE    FELIPE  Grooming  Affiliative       1\n</code></pre> </p> <p>Next we load this into Raphtory using the <code>load_edges_from_pandas</code> function, modelling it as a weighted multi-layer graph, with a layer per unique <code>behaviour</code>. </p>  Python <p> <code>Graph</code> <pre><code>import raphtory as rp\n\ng = rp.Graph()\ng.load_edges_from_pandas(\n    df=edges_df,\n    src=\"Actor\",\n    dst=\"Recipient\",\n    time=\"DateTime\",\n    layer_col=\"Behavior\",\n    properties=[\"Weight\"],\n)\nprint(g)\n</code></pre></p> <p>Output</p> <p><pre><code>Graph(number_of_nodes=22, number_of_edges=290, number_of_temporal_edges=3196, earliest_time=1560419400000, latest_time=1562756700000)\n</code></pre> </p>"},{"location":"user-guide/querying/2_graph-metrics/","title":"Graph metrics and functions","text":""},{"location":"user-guide/querying/2_graph-metrics/#basic-metrics","title":"Basic metrics","text":"<p>Now that we have our graph let's start probing it for some basic metrics, such as how many nodes and edges it contains and the time range over which it exists. </p> <p>Note, as the property APIs are the same for the graph, nodes and edges, these are discussed together in Property queries.</p> <p>Info</p> <p>In the below code segment you will see the functions <code>count_edges()</code> and <code>count_temporal_edges()</code> being called and returning different results. This is because <code>count_edges()</code> returns the number of unique edges and <code>count_temporal_edges()</code> returns the total edge updates which have occurred. </p> <p>The second is useful if you want to imagine each edge update as a separate connection between the two nodes. The edges can be accessed in this manner via <code>edge.explode()</code>, as is discussed in edge metrics and functions.</p>  Python <p> <code>Graph</code> <pre><code>print(\"Stats on the graph structure:\")\n\nnumber_of_nodes = g.count_nodes()\nnumber_of_edges = g.count_edges()\ntotal_interactions = g.count_temporal_edges()\nunique_layers = g.unique_layers\n\nprint(\"Number of nodes (Baboons):\", number_of_nodes)\nprint(\"Number of unique edges (src,dst,layer):\", number_of_edges)\nprint(\"Total interactions (edge updates):\", total_interactions)\nprint(\"Unique layers:\", unique_layers, \"\\n\")\n\n\nprint(\"Stats on the graphs time range:\")\n\nearliest_datetime = g.earliest_date_time\nlatest_datetime = g.latest_date_time\nearliest_epoch = g.earliest_time\nlatest_epoch = g.latest_time\n\nprint(\"Earliest datetime:\", earliest_datetime)\nprint(\"Latest datetime:\", latest_datetime)\nprint(\"Earliest time (Unix Epoch):\", earliest_epoch)\nprint(\"Latest time (Unix Epoch):\", latest_epoch)\n</code></pre></p> <p>Output</p> <p><pre><code>Stats on the graph structure:\nNumber of nodes (Baboons): 22\nNumber of unique edges (src,dst,layer): 290\nTotal interactions (edge updates): 3196\nUnique layers: ['_default', 'Grooming', 'Resting', 'Presenting', 'Playing with', 'Grunting-Lipsmacking', 'Threatening', 'Touching', 'Attacking', 'Avoiding', 'Chasing', 'Mounting', 'Copulating', 'Embracing', 'Supplanting', 'Submission', 'Carrying'] \n\nStats on the graphs time range:\nEarliest datetime: 2019-06-13 09:50:00+00:00\nLatest datetime: 2019-07-10 11:05:00+00:00\nEarliest time (Unix Epoch): 1560419400000\nLatest time (Unix Epoch): 1562756700000\n</code></pre> </p>"},{"location":"user-guide/querying/2_graph-metrics/#accessing-nodes-and-edges","title":"Accessing nodes and edges","text":"<p>Three types of functions are provided for accessing the nodes and edges within the graph: </p> <ul> <li>Existance check: Via <code>has_node()</code> and <code>has_edge()</code> you can check if an entity is present within the graph.</li> <li>Direct access: <code>node()</code> and <code>edge()</code> will return a node/edge object if the entity is present and <code>None</code> if it is not.</li> <li>Iterable access: <code>nodes</code> and <code>edges</code> will return iterables for all nodes/edges which can be used within a for loop or as part of a function chain.</li> </ul> <p>All of these functions are shown in the code below and will appear in several other examples throughout this tutorial.</p>  Python <p> <code>Graph</code> <pre><code>print(\"Checking if specific nodes and edges are in the graph:\")\nif g.has_node(id=\"LOME\"):\n    print(\"Lomme is in the graph\")\nif g.layer(\"Playing with\").has_edge(src=\"LOME\", dst=\"NEKKE\"):\n    print(\"Lomme has played with Nekke \\n\")\n\nprint(\"Getting individual nodes and edges:\")\nprint(g.node(\"LOME\"))\nprint(g.edge(\"LOME\", \"NEKKE\"), \"\\n\")\n\nprint(\"Getting iterators over all nodes and edges:\")\nprint(g.nodes)\nprint(g.edges)\n</code></pre></p> <p>Output</p> <p><pre><code>Checking if specific nodes and edges are in the graph:\nLomme is in the graph\nLomme has played with Nekke \n\nGetting individual nodes and edges:\nNode(name=LOME, earliest_time=1560419520000, latest_time=1562756100000)\nEdge(source=LOME, target=NEKKE, earliest_time=1560421080000, latest_time=1562755980000, properties={Weight: 1}, layer(s)=[Grooming, Resting, Playing with, Touching, Carrying]) \n\nGetting iterators over all nodes and edges:\nNodes(Node(name=ATMOSPHERE, earliest_time=1560419640000, latest_time=1562683260000), Node(name=FEYA, earliest_time=1560420000000, latest_time=1562756040000), Node(name=MALI, earliest_time=1560422040000, latest_time=1562755320000), Node(name=ANGELE, earliest_time=1560419400000, latest_time=1562754600000), Node(name=EWINE, earliest_time=1560442020000, latest_time=1562754600000), Node(name=LIPS, earliest_time=1560419460000, latest_time=1562756700000), Node(name=FANA, earliest_time=1560420000000, latest_time=1562754600000), Node(name=FELIPE, earliest_time=1560419400000, latest_time=1562756700000), Node(name=HARLEM, earliest_time=1560423540000, latest_time=1562754900000), Node(name=NEKKE, earliest_time=1560419520000, latest_time=1562756700000), ...)\nEdges(Edge(source=ATMOSPHERE, target=LIPS, earliest_time=1560420000000, latest_time=1560420000000, properties={Weight: 1}, layer(s)=[Playing with]), Edge(source=PIPO, target=KALI, earliest_time=1560420660000, latest_time=1562752560000, properties={Weight: 1}, layer(s)=[Grooming, Resting, Grunting-Lipsmacking, Touching, Chasing, Mounting, Copulating]), Edge(source=FEYA, target=FANA, earliest_time=1560420000000, latest_time=1562248680000, properties={Weight: 1}, layer(s)=[Resting, Presenting, Touching]), Edge(source=LIPS, target=ATMOSPHERE, earliest_time=1560420060000, latest_time=1560420060000, properties={Weight: 1}, layer(s)=[Grooming]), Edge(source=ANGELE, target=FELIPE, earliest_time=1560419400000, latest_time=1562753640000, properties={Weight: 1}, layer(s)=[Grooming, Resting, Presenting, Grunting-Lipsmacking, Copulating, Submission]), Edge(source=NEKKE, target=LIPS, earliest_time=1560421980000, latest_time=1562668860000, properties={Weight: 1}, layer(s)=[Resting, Playing with, Embracing]), Edge(source=FELIPE, target=ANGELE, earliest_time=1560419460000, latest_time=1562754600000, properties={Weight: 1}, layer(s)=[Resting, Presenting, Grunting-Lipsmacking, Touching, Chasing, Mounting, Embracing, Supplanting, Submission]), Edge(source=FELIPE, target=LIPS, earliest_time=1560419460000, latest_time=1562251080000, properties={Weight: 1}, layer(s)=[Resting, Touching]), Edge(source=NEKKE, target=MAKO, earliest_time=1560421980000, latest_time=1562751120000, properties={Weight: 1}, layer(s)=[Grooming, Resting, Presenting, Playing with, Embracing]), Edge(source=PIPO, target=FELIPE, earliest_time=1560420720000, latest_time=1562151240000, properties={Weight: 1}, layer(s)=[Resting, Presenting, Grunting-Lipsmacking, Avoiding]), ...)\n</code></pre> </p>"},{"location":"user-guide/querying/3_node-metrics/","title":"Node metrics and functions","text":"<p>Nodes can be accessed by storing the object returned from a call to <code>add_node()</code>, by directly asking for a specific entity via <code>node()</code>, or by iterating over all entities via <code>nodes</code>. Once you have a node, we can ask it some questions. </p>"},{"location":"user-guide/querying/3_node-metrics/#update-history","title":"Update history","text":"<p>Nodes have functions for querying their earliest/latest update time (as an epoch or datetime) as well as for accessing their full history (<code>history()</code>/<code>history_date_time()</code>). In the code below we create a node object for the monkey <code>Felipe</code> and see when their updates occurred. </p>  Python <p> <code>Node</code> <pre><code>v = g.node(\"FELIPE\")\nprint(\n    f\"{v.name}'s first interaction was at {v.earliest_date_time} and their last interaction was at {v.latest_date_time}\\n\"\n)\nhistory = v.history_date_time()\n# We format the returned datetime objects here to make the list more readable\nhistory_formatted = [date.strftime(\"%Y-%m-%d %H:%M:%S\") for date in history]\n\nprint(f\"{v.name} had interactions at the following times: {history_formatted}\\n\")\n</code></pre></p> <p>Output</p> <p><pre><code>FELIPE's first interaction was at 2019-06-13 09:50:00+00:00 and their last interaction was at 2019-07-10 11:05:00+00:00\n\nFELIPE had interactions at the following times: ['2019-06-13 09:50:00', '2019-06-13 09:51:00', '2019-06-13 09:52:00', '2019-06-13 09:53:00', '2019-06-13 09:54:00', '2019-06-13 10:12:00', '2019-06-13 10:21:00', '2019-06-13 10:43:00', '2019-06-13 10:56:00', '2019-06-13 10:57:00', '2019-06-13 11:00:00', '2019-06-13 14:50:00', '2019-06-13 14:51:00', '2019-06-13 14:54:00', '2019-06-13 15:32:00', '2019-06-13 15:33:00', '2019-06-13 15:36:00', '2019-06-13 15:44:00', '2019-06-13 16:03:00', '2019-06-13 16:04:00', '2019-06-13 16:06:00', '2019-06-13 16:24:00', '2019-06-14 09:20:00', '2019-06-14 09:29:00', '2019-06-14 10:06:00', '2019-06-14 10:19:00', '2019-06-14 10:32:00', '2019-06-14 10:33:00', '2019-06-14 10:35:00', '2019-06-14 14:41:00', '2019-06-14 14:47:00', '2019-06-14 14:48:00', '2019-06-14 14:49:00', '2019-06-14 14:51:00', '2019-06-14 15:08:00', '2019-06-14 15:20:00', '2019-06-14 15:22:00', '2019-06-14 15:29:00', '2019-06-14 15:31:00', '2019-06-14 15:32:00', '2019-06-17 11:02:00', '2019-06-17 11:04:00', '2019-06-17 12:49:00', '2019-06-17 14:01:00', '2019-06-17 14:02:00', '2019-06-18 10:25:00', '2019-06-18 10:36:00', '2019-06-18 10:40:00', '2019-06-18 11:01:00', '2019-06-18 13:42:00', '2019-06-18 13:44:00', '2019-06-18 13:45:00', '2019-06-19 08:56:00', '2019-06-19 08:58:00', '2019-06-19 08:59:00', '2019-06-19 09:11:00', '2019-06-19 09:12:00', '2019-06-19 09:14:00', '2019-06-19 09:26:00', '2019-06-19 09:31:00', '2019-06-19 09:42:00', '2019-06-19 10:25:00', '2019-06-19 10:26:00', '2019-06-19 10:27:00', '2019-06-19 11:25:00', '2019-06-19 12:01:00', '2019-06-19 12:05:00', '2019-06-19 12:06:00', '2019-06-19 12:23:00', '2019-06-19 12:34:00', '2019-06-19 12:43:00', '2019-06-19 12:48:00', '2019-06-19 12:49:00', '2019-06-19 12:50:00', '2019-06-20 10:05:00', '2019-06-20 10:15:00', '2019-06-20 10:36:00', '2019-06-20 10:51:00', '2019-06-20 11:17:00', '2019-06-20 14:56:00', '2019-06-20 14:57:00', '2019-06-20 14:59:00', '2019-06-20 15:08:00', '2019-06-20 15:09:00', '2019-06-20 15:20:00', '2019-06-20 15:27:00', '2019-06-20 15:30:00', '2019-06-20 15:55:00', '2019-06-21 09:43:00', '2019-06-21 10:38:00', '2019-06-21 10:39:00', '2019-06-21 11:11:00', '2019-06-21 11:14:00', '2019-06-21 11:39:00', '2019-06-21 11:40:00', '2019-06-21 11:46:00', '2019-06-21 11:47:00', '2019-06-21 11:48:00', '2019-06-21 11:49:00', '2019-06-21 12:03:00', '2019-06-21 12:41:00', '2019-06-21 12:57:00', '2019-06-21 13:00:00', '2019-06-21 13:01:00', '2019-06-21 13:02:00', '2019-06-24 10:54:00', '2019-06-24 10:56:00', '2019-06-24 10:57:00', '2019-06-24 10:58:00', '2019-06-24 10:59:00', '2019-06-24 11:01:00', '2019-06-24 11:08:00', '2019-06-24 11:09:00', '2019-06-24 11:14:00', '2019-06-24 11:22:00', '2019-06-24 15:40:00', '2019-06-24 15:41:00', '2019-06-24 15:42:00', '2019-06-24 15:43:00', '2019-06-24 16:09:00', '2019-06-24 16:11:00', '2019-06-25 10:25:00', '2019-06-25 10:30:00', '2019-06-25 10:48:00', '2019-06-25 10:49:00', '2019-06-25 11:13:00', '2019-06-25 11:14:00', '2019-06-25 11:26:00', '2019-06-25 15:11:00', '2019-06-25 15:17:00', '2019-06-25 15:52:00', '2019-06-25 15:54:00', '2019-06-25 16:03:00', '2019-06-25 16:04:00', '2019-06-25 16:09:00', '2019-06-26 09:10:00', '2019-06-26 09:11:00', '2019-06-26 09:32:00', '2019-06-26 09:33:00', '2019-06-26 09:53:00', '2019-06-26 09:54:00', '2019-06-26 09:58:00', '2019-06-26 10:05:00', '2019-06-26 10:06:00', '2019-06-26 10:37:00', '2019-06-26 10:39:00', '2019-06-26 13:22:00', '2019-06-26 13:35:00', '2019-06-26 13:39:00', '2019-06-26 13:40:00', '2019-06-26 14:17:00', '2019-06-26 14:18:00', '2019-06-27 09:31:00', '2019-06-27 09:37:00', '2019-06-27 12:29:00', '2019-06-27 12:46:00', '2019-06-27 13:03:00', '2019-06-27 13:49:00', '2019-06-27 13:52:00', '2019-06-27 13:53:00', '2019-06-28 10:15:00', '2019-06-28 10:16:00', '2019-06-28 10:17:00', '2019-06-28 10:18:00', '2019-06-28 10:19:00', '2019-06-28 10:20:00', '2019-06-28 11:12:00', '2019-06-28 11:13:00', '2019-07-01 08:44:00', '2019-07-01 08:46:00', '2019-07-01 08:49:00', '2019-07-01 08:51:00', '2019-07-01 09:06:00', '2019-07-01 09:21:00', '2019-07-01 10:13:00', '2019-07-01 13:20:00', '2019-07-01 14:45:00', '2019-07-02 08:52:00', '2019-07-02 13:32:00', '2019-07-02 13:33:00', '2019-07-02 13:34:00', '2019-07-02 13:35:00', '2019-07-02 13:36:00', '2019-07-02 14:35:00', '2019-07-02 14:39:00', '2019-07-03 09:27:00', '2019-07-03 09:39:00', '2019-07-03 09:41:00', '2019-07-03 10:14:00', '2019-07-03 10:15:00', '2019-07-03 10:16:00', '2019-07-03 10:17:00', '2019-07-03 10:18:00', '2019-07-03 10:54:00', '2019-07-03 11:16:00', '2019-07-03 11:17:00', '2019-07-03 11:37:00', '2019-07-03 12:03:00', '2019-07-03 12:05:00', '2019-07-04 09:30:00', '2019-07-04 09:31:00', '2019-07-04 09:39:00', '2019-07-04 09:45:00', '2019-07-04 09:46:00', '2019-07-04 10:00:00', '2019-07-04 10:25:00', '2019-07-04 10:55:00', '2019-07-04 10:59:00', '2019-07-04 14:02:00', '2019-07-04 14:04:00', '2019-07-04 14:05:00', '2019-07-04 14:30:00', '2019-07-04 14:38:00', '2019-07-04 15:09:00', '2019-07-04 15:19:00', '2019-07-05 10:10:00', '2019-07-05 10:12:00', '2019-07-05 10:13:00', '2019-07-05 10:20:00', '2019-07-05 10:46:00', '2019-07-05 11:05:00', '2019-07-05 11:40:00', '2019-07-05 11:41:00', '2019-07-05 11:57:00', '2019-07-05 12:57:00', '2019-07-05 13:02:00', '2019-07-05 13:07:00', '2019-07-05 13:13:00', '2019-07-08 11:34:00', '2019-07-08 11:39:00', '2019-07-08 11:40:00', '2019-07-08 11:46:00', '2019-07-08 11:50:00', '2019-07-08 12:37:00', '2019-07-08 14:32:00', '2019-07-08 14:33:00', '2019-07-08 15:42:00', '2019-07-08 15:48:00', '2019-07-08 15:51:00', '2019-07-09 10:57:00', '2019-07-09 10:59:00', '2019-07-09 11:01:00', '2019-07-09 11:17:00', '2019-07-09 11:20:00', '2019-07-09 13:37:00', '2019-07-09 13:38:00', '2019-07-09 13:39:00', '2019-07-09 13:40:00', '2019-07-09 14:34:00', '2019-07-09 14:36:00', '2019-07-09 14:37:00', '2019-07-10 10:00:00', '2019-07-10 10:06:00', '2019-07-10 10:14:00', '2019-07-10 10:30:00', '2019-07-10 10:44:00', '2019-07-10 11:05:00']\n</code></pre> </p>"},{"location":"user-guide/querying/3_node-metrics/#neighbours-edges-and-paths","title":"Neighbours, edges and paths","text":"<p>To investigate who a node is connected with we can ask for its <code>degree()</code>, <code>edges</code>, or <code>neighbours</code>. As Raphtory is a directed graph, all of these functions also have an <code>in_</code> and <code>out_</code> variation, allowing you get only incoming and outgoing connections respectively. These functions return the following:</p> <ul> <li>degree: A count of the number of unique connections a node has.</li> <li>edges: An iterable (<code>Edges</code>) of edge objects, one for each unique <code>(src,dst)</code> pair.</li> <li>neighbours: An iterable of node objects (<code>PathFromNode</code>), one for each entity the original node shares an edge with.</li> </ul> <p>In the code below we call a selection of these functions to show the sort of questions you may ask. </p> <p>Info</p> <p>The final section of the code makes use of <code>v.neighbours.name.collect()</code> - this is a chain of functions which are run on each node in the <code>PathFromNode</code> iterable. We will discuss these sort of operations more in Chaining functions. </p>  Python <p> <code>Node</code> <pre><code>v = g.node(\"FELIPE\")\nv_name = v.name\nin_degree = v.in_degree()\nout_degree = v.out_degree()\nin_edges = v.in_edges\nneighbours = v.neighbours\nneighbour_names = v.neighbours.name.collect()\n\nprint(\n    f\"{v_name} has {in_degree} incoming interactions and {out_degree} outgoing interactions.\\n\"\n)\nprint(in_edges)\nprint(neighbours, \"\\n\")\nprint(f\"{v_name} interacted with the following baboons {neighbour_names}\")\n</code></pre></p> <p>Output</p> <p><pre><code>FELIPE has 17 incoming interactions and 18 outgoing interactions.\n\nEdges(Edge(source=ATMOSPHERE, target=FELIPE, earliest_time=1560524880000, latest_time=1561638540000, properties={Weight: 1}, layer(s)=[Resting]), Edge(source=FEYA, target=FELIPE, earliest_time=1560853500000, latest_time=1562586000000, properties={Weight: 1}, layer(s)=[Resting, Presenting]), Edge(source=MALI, target=FELIPE, earliest_time=1561117140000, latest_time=1562753160000, properties={Weight: 1}, layer(s)=[Grooming, Resting, Presenting]), Edge(source=ANGELE, target=FELIPE, earliest_time=1560419400000, latest_time=1562753640000, properties={Weight: 1}, layer(s)=[Grooming, Resting, Presenting, Grunting-Lipsmacking, Copulating, Submission]), Edge(source=EWINE, target=FELIPE, earliest_time=1560523260000, latest_time=1562585640000, properties={Weight: 1}, layer(s)=[Grooming, Resting, Presenting, Avoiding]), Edge(source=LIPS, target=FELIPE, earliest_time=1560423600000, latest_time=1562756700000, properties={Weight: 1}, layer(s)=[Grooming, Resting, Presenting, Submission]), Edge(source=FANA, target=FELIPE, earliest_time=1560526140000, latest_time=1562752800000, properties={Weight: 1}, layer(s)=[Grooming, Resting, Presenting, Touching, Copulating, Submission]), Edge(source=HARLEM, target=FELIPE, earliest_time=1561975980000, latest_time=1562232600000, properties={Weight: 1}, layer(s)=[Resting, Playing with]), Edge(source=NEKKE, target=FELIPE, earliest_time=1560443040000, latest_time=1562596380000, properties={Weight: 1}, layer(s)=[Resting, Presenting, Grunting-Lipsmacking, Touching, Embracing]), Edge(source=PIPO, target=FELIPE, earliest_time=1560420720000, latest_time=1562151240000, properties={Weight: 1}, layer(s)=[Resting, Presenting, Grunting-Lipsmacking, Avoiding]), ...)\nPathFromNode(Node(name=ATMOSPHERE, earliest_time=1560419640000, latest_time=1562683260000), Node(name=FEYA, earliest_time=1560420000000, latest_time=1562756040000), Node(name=MALI, earliest_time=1560422040000, latest_time=1562755320000), Node(name=ANGELE, earliest_time=1560419400000, latest_time=1562754600000), Node(name=EWINE, earliest_time=1560442020000, latest_time=1562754600000), Node(name=LIPS, earliest_time=1560419460000, latest_time=1562756700000), Node(name=FANA, earliest_time=1560420000000, latest_time=1562754600000), Node(name=HARLEM, earliest_time=1560423540000, latest_time=1562754900000), Node(name=NEKKE, earliest_time=1560419520000, latest_time=1562756700000), Node(name=PIPO, earliest_time=1560420660000, latest_time=1562752560000), ...) \n\nFELIPE interacted with the following baboons ['ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'VIOLETTE', 'PETOULETTE', 'SELF']\n</code></pre> </p>"},{"location":"user-guide/querying/4_edge-metrics/","title":"Edge metrics and functions","text":"<p>Edges can be accessed by storing the object returned from a call to <code>add_edge()</code>, by directly asking for a specific edge via <code>edge()</code>, or by iterating over all edges via <code>in-edges</code>/<code>out-edges</code>/<code>edges</code>. </p>"},{"location":"user-guide/querying/4_edge-metrics/#edge-structure-and-update-history","title":"Edge structure and update history","text":"<p>An edge object in Raphtory will by default contain all updates over all layers between the given source and destination nodes. As an example of this, we can look at the two edges between <code>FELIPE</code> and <code>MAKO</code> (one for each direction). </p> <p>In the code below we create the two edge objects by requesting them from the graph and then print out the layers each is involved in via <code>layer_names</code>. We can see here that there are multiple behaviours in each direction represented within the edges.</p> <p>Following this we access the history and earliest/latest update time, as we have previously with the graph and nodes. This update history consists all interactions across all the aforementioned layers.</p> <p>Info</p> <p>Note that we call <code>e.src.name</code> because <code>src</code> and <code>dst</code> return a node object, instead of just an id/name.</p>  Python <p> <code>Node</code> <pre><code>e = g.edge(\"FELIPE\", \"MAKO\")\ne_reversed = g.edge(\"MAKO\", \"FELIPE\")\ne_history = [date.strftime(\"%Y-%m-%d %H:%M:%S\") for date in e.history_date_time()]\ne_reversed_history = [\n    date.strftime(\"%Y-%m-%d %H:%M:%S\") for date in e_reversed.history_date_time()\n]\n\nprint(\n    f\"The edge from {e.src.name} to {e.dst.name} covers the following layers: {e.layer_names}\"\n)\nprint(\n    f\"and has updates between {e.earliest_date_time} and {e.latest_date_time} at the following times: {e_history}\\n\"\n)\nprint(\n    f\"The edge from {e_reversed.src.name} to {e_reversed.dst.name} covers the following layers: {e_reversed.layer_names}\"\n)\nprint(\n    f\"and has updates between {e_reversed.earliest_date_time} and {e_reversed.latest_date_time} at the following times: {e_reversed_history}\"\n)\n</code></pre></p> <p>Output</p> <p><pre><code>The edge from FELIPE to MAKO covers the following layers: ['Grooming', 'Resting', 'Playing with', 'Grunting-Lipsmacking', 'Touching', 'Embracing', 'Carrying']\nand has updates between 2019-06-13 14:50:00+00:00 and 2019-07-09 11:17:00+00:00 at the following times: ['2019-06-13 14:50:00', '2019-06-13 14:54:00', '2019-06-19 09:11:00', '2019-06-20 15:08:00', '2019-06-20 15:08:00', '2019-06-20 15:09:00', '2019-06-21 11:47:00', '2019-06-24 10:58:00', '2019-06-24 10:58:00', '2019-06-24 10:59:00', '2019-06-24 10:59:00', '2019-06-24 10:59:00', '2019-06-24 10:59:00', '2019-06-24 10:59:00', '2019-06-24 15:41:00', '2019-06-24 15:41:00', '2019-06-24 15:41:00', '2019-06-24 15:42:00', '2019-06-27 13:53:00', '2019-06-28 10:18:00', '2019-06-28 10:19:00', '2019-07-01 08:46:00', '2019-07-03 10:16:00', '2019-07-03 10:16:00', '2019-07-03 10:17:00', '2019-07-03 10:17:00', '2019-07-03 10:18:00', '2019-07-09 11:17:00']\n\nThe edge from MAKO to FELIPE covers the following layers: ['Grooming', 'Resting', 'Presenting', 'Playing with', 'Grunting-Lipsmacking', 'Embracing']\nand has updates between 2019-06-19 09:42:00+00:00 and 2019-07-09 13:40:00+00:00 at the following times: ['2019-06-19 09:42:00', '2019-06-20 15:08:00', '2019-06-20 15:08:00', '2019-06-20 15:08:00', '2019-06-24 10:58:00', '2019-06-24 11:14:00', '2019-06-24 11:14:00', '2019-06-24 16:09:00', '2019-06-24 16:11:00', '2019-06-26 09:10:00', '2019-06-26 09:11:00', '2019-06-28 10:17:00', '2019-07-02 14:35:00', '2019-07-04 14:30:00', '2019-07-04 14:30:00', '2019-07-09 13:37:00', '2019-07-09 13:37:00', '2019-07-09 13:37:00', '2019-07-09 13:38:00', '2019-07-09 13:39:00', '2019-07-09 13:39:00', '2019-07-09 13:40:00']\n</code></pre> </p>"},{"location":"user-guide/querying/4_edge-metrics/#exploded-edges","title":"Exploded edges","text":"<p>The very first question you may have after reading this is \"What if I don't want all of the layers?\". For this Raphtory offers you three different ways to split the edge, depending on your use case:</p> <ul> <li><code>.layers()</code>: which takes a list of layer names and returns a new <code>Edge View</code> which only contains updates for the specified layers - This is discussed in more detail in the Layer views chapter.</li> <li><code>.explode_layers()</code>: which returns an iterable of <code>Edge Views</code>, each containing the updates for one layer.</li> <li><code>.explode()</code>: which returns an <code>Exploded Edge</code> containing only the information from one call to <code>add_edge()</code> i.e. an edge object for each update. </li> </ul> <p>In the code below you can see usage of all of these functions. We first call <code>explode_layers()</code>, seeing which layer each edge object represents and output its update history. Next we fully <code>explode()</code> the edge and see each update as an individual object. Thirdly we use the <code>layer()</code> function to look at only the <code>Touching</code> and <code>Carrying</code> layers and chain this with a call to <code>explode()</code> to see the separate updates. </p> <p>Info</p> <p>Within the examples and in the API documentation you will see singular and plural versions what appear to be the same function (i.e. <code>.layer_names/.layer_name</code> <code>.history()/.time</code>). </p> <p>For clarity - singular functions (<code>.layer_name/.time</code>) can be called on exploded edges and plural functions (<code>.layer_names/.history()</code>) can be called on standard edges.</p>  Python <p> <code>Node</code> <pre><code>print(\"Update history per layer:\")\nfor e in g.edge(\"FELIPE\", \"MAKO\").explode_layers():\n    e_history = [date.strftime(\"%Y-%m-%d %H:%M:%S\") for date in e.history_date_time()]\n    print(\n        f\"{e.src.name} interacted with {e.dst.name} with the following behaviour '{e.layer_name}' at this times: {e_history}\"\n    )\n\nprint()\nprint(\"Individual updates as edges:\")\nfor e in g.edge(\"FELIPE\", \"MAKO\").explode():\n    print(\n        f\"At {e.date_time} {e.src.name} interacted with {e.dst.name} in the following manner: '{e.layer_name}'\"\n    )\n\nprint()\nprint(\"Individual updates for 'Touching' and 'Carrying:\")\nfor e in g.edge(\"FELIPE\", \"MAKO\").layers([\"Touching\", \"Carrying\"]).explode():\n    print(\n        f\"At {e.date_time} {e.src.name} interacted with {e.dst.name} in the following manner: '{e.layer_name}'\"\n    )\n</code></pre></p> <p>Output</p> <p><pre><code>Update history per layer:\nFELIPE interacted with MAKO with the following behaviour 'Grooming' at this times: ['2019-06-20 15:08:00', '2019-06-20 15:09:00']\nFELIPE interacted with MAKO with the following behaviour 'Resting' at this times: ['2019-06-13 14:50:00', '2019-06-13 14:54:00', '2019-06-19 09:11:00', '2019-06-21 11:47:00', '2019-06-24 10:58:00', '2019-06-24 15:41:00', '2019-06-24 15:41:00', '2019-06-24 15:41:00', '2019-06-27 13:53:00', '2019-07-01 08:46:00', '2019-07-03 10:17:00', '2019-07-09 11:17:00']\nFELIPE interacted with MAKO with the following behaviour 'Playing with' at this times: ['2019-06-24 10:58:00', '2019-06-24 10:59:00', '2019-06-24 10:59:00', '2019-06-24 15:42:00', '2019-07-03 10:16:00', '2019-07-03 10:16:00', '2019-07-03 10:18:00']\nFELIPE interacted with MAKO with the following behaviour 'Grunting-Lipsmacking' at this times: ['2019-06-24 10:59:00', '2019-06-28 10:18:00', '2019-06-28 10:19:00']\nFELIPE interacted with MAKO with the following behaviour 'Touching' at this times: ['2019-07-03 10:17:00']\nFELIPE interacted with MAKO with the following behaviour 'Embracing' at this times: ['2019-06-24 10:59:00']\nFELIPE interacted with MAKO with the following behaviour 'Carrying' at this times: ['2019-06-20 15:08:00', '2019-06-24 10:59:00']\n\nIndividual updates as edges:\nAt 2019-06-13 14:50:00+00:00 FELIPE interacted with MAKO in the following manner: 'Resting'\nAt 2019-06-13 14:54:00+00:00 FELIPE interacted with MAKO in the following manner: 'Resting'\nAt 2019-06-19 09:11:00+00:00 FELIPE interacted with MAKO in the following manner: 'Resting'\nAt 2019-06-20 15:08:00+00:00 FELIPE interacted with MAKO in the following manner: 'Carrying'\nAt 2019-06-20 15:08:00+00:00 FELIPE interacted with MAKO in the following manner: 'Grooming'\nAt 2019-06-20 15:09:00+00:00 FELIPE interacted with MAKO in the following manner: 'Grooming'\nAt 2019-06-21 11:47:00+00:00 FELIPE interacted with MAKO in the following manner: 'Resting'\nAt 2019-06-24 10:58:00+00:00 FELIPE interacted with MAKO in the following manner: 'Resting'\nAt 2019-06-24 10:58:00+00:00 FELIPE interacted with MAKO in the following manner: 'Playing with'\nAt 2019-06-24 10:59:00+00:00 FELIPE interacted with MAKO in the following manner: 'Playing with'\nAt 2019-06-24 10:59:00+00:00 FELIPE interacted with MAKO in the following manner: 'Carrying'\nAt 2019-06-24 10:59:00+00:00 FELIPE interacted with MAKO in the following manner: 'Embracing'\nAt 2019-06-24 10:59:00+00:00 FELIPE interacted with MAKO in the following manner: 'Grunting-Lipsmacking'\nAt 2019-06-24 10:59:00+00:00 FELIPE interacted with MAKO in the following manner: 'Playing with'\nAt 2019-06-24 15:41:00+00:00 FELIPE interacted with MAKO in the following manner: 'Resting'\nAt 2019-06-24 15:41:00+00:00 FELIPE interacted with MAKO in the following manner: 'Resting'\nAt 2019-06-24 15:41:00+00:00 FELIPE interacted with MAKO in the following manner: 'Resting'\nAt 2019-06-24 15:42:00+00:00 FELIPE interacted with MAKO in the following manner: 'Playing with'\nAt 2019-06-27 13:53:00+00:00 FELIPE interacted with MAKO in the following manner: 'Resting'\nAt 2019-06-28 10:18:00+00:00 FELIPE interacted with MAKO in the following manner: 'Grunting-Lipsmacking'\nAt 2019-06-28 10:19:00+00:00 FELIPE interacted with MAKO in the following manner: 'Grunting-Lipsmacking'\nAt 2019-07-01 08:46:00+00:00 FELIPE interacted with MAKO in the following manner: 'Resting'\nAt 2019-07-03 10:16:00+00:00 FELIPE interacted with MAKO in the following manner: 'Playing with'\nAt 2019-07-03 10:16:00+00:00 FELIPE interacted with MAKO in the following manner: 'Playing with'\nAt 2019-07-03 10:17:00+00:00 FELIPE interacted with MAKO in the following manner: 'Touching'\nAt 2019-07-03 10:17:00+00:00 FELIPE interacted with MAKO in the following manner: 'Resting'\nAt 2019-07-03 10:18:00+00:00 FELIPE interacted with MAKO in the following manner: 'Playing with'\nAt 2019-07-09 11:17:00+00:00 FELIPE interacted with MAKO in the following manner: 'Resting'\n\nIndividual updates for 'Touching' and 'Carrying:\nAt 2019-06-20 15:08:00+00:00 FELIPE interacted with MAKO in the following manner: 'Carrying'\nAt 2019-06-24 10:59:00+00:00 FELIPE interacted with MAKO in the following manner: 'Carrying'\nAt 2019-07-03 10:17:00+00:00 FELIPE interacted with MAKO in the following manner: 'Touching'\n</code></pre> </p>"},{"location":"user-guide/querying/5_properties/","title":"Property queries","text":"<p>As you will have seen in the ingestion tutorial, graphs, nodes and edges may all have <code>constant</code> and <code>temporal</code> properties, consisting of a wide range of data types. Raphtory provides a unified API for accessing this data via the <code>Properties</code> object available on all classes by calling <code>.properties</code>. </p> <p>This <code>Properties</code> class offers several functions for you to access the values you are interested in in the most appropriate format. To demonstrate this let's create a simple graph with one node that has a variety of different properties, both temporal and constant. </p> <p>We can grab this nodes property object and call all of the functions to access the data:</p> <ul> <li><code>keys()</code>: Returns all of the property keys (names).</li> <li><code>values()</code>: Returns the latest value for each property.</li> <li><code>items()</code>: Combines the <code>keys()</code> and <code>values()</code> into a list of tuples.</li> <li><code>get()</code>: Returns the latest value for a given key if the property exists or <code>None</code> if it does not.</li> <li><code>as_dict()</code>: Converts the <code>Properties</code> object into a standard python dictionary.</li> </ul>  Python <p> <code>Node</code> <pre><code>from raphtory import Graph\n\nproperty_g = Graph()\n# Create the node and add a variety of temporal properties\nv = property_g.add_node(\n    timestamp=1,\n    id=\"User\",\n    properties={\"count\": 1, \"greeting\": \"hi\", \"encrypted\": True},\n)\nproperty_g.add_node(\n    timestamp=2,\n    id=\"User\",\n    properties={\"count\": 2, \"balance\": 0.6, \"encrypted\": False},\n)\nproperty_g.add_node(\n    timestamp=3,\n    id=\"User\",\n    properties={\"balance\": 0.9, \"greeting\": \"hello\", \"encrypted\": True},\n)\n# Add some constant properties\nv.add_constant_properties(\n    properties={\n        \"inner data\": {\"name\": \"bob\", \"value list\": [1, 2, 3]},\n        \"favourite greetings\": [\"hi\", \"hello\", \"howdy\"],\n    },\n)\n# Call all of the functions on the properties object\nproperties = v.properties\nprint(\"Property keys:\", properties.keys())\nprint(\"Property values:\", properties.values())\nprint(\"Property tuples:\", properties.items())\nprint(\"Latest value of balance:\", properties.get(\"balance\"))\nprint(\"Property keys:\", properties.as_dict(), \"\\n\")\n\n# Access the keys of the constant and temporal properties individually\nconstant_properties = properties.constant\ntemporal_properties = properties.temporal\nprint(\"Constant property keys:\", constant_properties.keys())\nprint(\"Constant property keys:\", temporal_properties.keys())\n</code></pre></p> <p>Output</p> <p><pre><code>Property keys: ['count', 'greeting', 'encrypted', 'balance', 'inner data', 'favourite greetings']\nProperty values: [2, 'hello', True, 0.9, {'value list': [1, 2, 3], 'name': 'bob'}, ['hi', 'hello', 'howdy']]\nProperty tuples: [('count', 2), ('greeting', 'hello'), ('encrypted', True), ('balance', 0.9), ('inner data', {'value list': [1, 2, 3], 'name': 'bob'}), ('favourite greetings', ['hi', 'hello', 'howdy'])]\nLatest value of balance: 0.9\nProperty keys: {'count': 2, 'greeting': 'hello', 'inner data': {'value list': [1, 2, 3], 'name': 'bob'}, 'encrypted': True, 'favourite greetings': ['hi', 'hello', 'howdy'], 'balance': 0.9} \n\nConstant property keys: ['inner data', 'favourite greetings']\nConstant property keys: ['count', 'greeting', 'encrypted', 'balance']\n</code></pre> </p> <p>The <code>Properties</code> class also has two attributes <code>constant</code> and <code>temporal</code> which have all of the above functions, but are restricted to only the properties which fall within their respective catagories. </p> <p>Info</p> <p>The semantics for <code>ConstantProperties</code> are exactly the same as described above. <code>TemporalProperties</code> on the other hand allow you to do much more, as is discussed below.</p>"},{"location":"user-guide/querying/5_properties/#temporal-specific-functions","title":"Temporal specific functions","text":"<p>As temporal properties have a history, we may often want to do more than just look at the latest value. As such, calling <code>get()</code>, <code>values()</code> or <code>items()</code> on <code>TemporalProperties</code> will return a <code>TemporalProp</code> object which contains all of the value history.</p> <p><code>TemporalProp</code> has a host of helper functions covering anything that you may want to do with this history. This includes:</p> <ul> <li><code>value()</code>/<code>values()</code>: Get the latest value or all values of the property.</li> <li><code>at()</code>: Get the latest value of the property at the specified time.</li> <li><code>history()</code>/<code>history_date_time()</code>: Get the timestamps of all updates to the property.</li> <li><code>items()</code>/<code>items_date_time()</code>: Merges <code>values()</code> and <code>history()</code>/<code>history_date_time()</code> into a list of tuples.</li> <li><code>mean()</code>/<code>median()</code>/<code>average()</code>: If the property is orderable, get the average value for the property.</li> <li><code>min()</code>/<code>max()</code>: If the property is orderable, get the minimum or maximum value.</li> <li><code>count()</code>: Get the number of updates which have occurred</li> <li><code>sum()</code>: If the property is additive, sum the values and return the result.</li> </ul> <p>In the code below, we call a subset of these functions on the <code>Weight</code> property of the edge between <code>FELIPE</code> and <code>MAKO</code> in our monkey graph.</p>  Python <p> <code>Edge</code> <pre><code>properties = g.edge(\"FELIPE\", \"MAKO\").properties.temporal\nprint(\"Property keys:\", properties.keys())\nweight_prop = properties.get(\"Weight\")\nprint(\"Weight property history:\", weight_prop.items())\nprint(\"Average interaction weight:\", weight_prop.mean())\nprint(\"Total interactions:\", weight_prop.count())\nprint(\"Total interaction weight:\", weight_prop.sum())\n</code></pre></p> <p>Output</p> <p><pre><code>Property keys: ['Weight']\nWeight property history: [(1560437400000, 1), (1560437640000, 1), (1560935460000, 1), (1561043280000, 0), (1561043280000, 1), (1561043340000, 1), (1561117620000, 1), (1561373880000, 1), (1561373880000, 1), (1561373940000, 1), (1561373940000, 0), (1561373940000, 1), (1561373940000, 1), (1561373940000, 1), (1561390860000, 1), (1561390860000, 1), (1561390860000, 1), (1561390920000, 1), (1561643580000, 1), (1561717080000, 1), (1561717140000, 1), (1561970760000, 1), (1562148960000, 1), (1562148960000, 1), (1562149020000, 1), (1562149020000, 1), (1562149080000, 1), (1562671020000, 1)]\nAverage interaction weight: 0.9285714285714286\nTotal interactions: 28\nTotal interaction weight: 26\n</code></pre> </p>"},{"location":"user-guide/querying/6_chaining/","title":"Chaining functions","text":"<p>When we called <code>v.neighbours</code> in Node metrics, a <code>PathFromNode</code> was returned rather than a <code>List</code>. This, along with all other iterables previously mentioned (<code>Nodes</code>,<code>Edges</code>,<code>Properties</code>), are lazy data structures which allow you to chain multiple functions together before a final execution. </p> <p>For example, for a node <code>v</code>, <code>v.neighbours.neighbours</code> will return the two-hop neighbours. The first call of <code>neighbours</code> returns the immediate neighbours of <code>v</code>, the second applies the<code>neighbours</code> function to each of the nodes returned by the first call. </p> <p>We can continue this chain for as long as we like, with any functions in the Node, Edge or Property API until we either: </p> <ul> <li>Call <code>.collect()</code>, which will execute the chain and return the result.</li> <li>Execute the chain by handing it to a python function such as <code>list()</code>, <code>set()</code>, <code>sum()</code>, etc.</li> <li>Iterate through the chain via a loop/list comprehension.</li> </ul> <p>We can see a basic example of these function chains below in which we get the names of all the monkeys, the names of their two-hop neighbours, zip these together and print the result.</p>  Python <p> <code>Edges</code> <pre><code>node_names = g.nodes.name\ntwo_hop_neighbours = g.nodes.neighbours.neighbours.name.collect()\ncombined = zip(node_names, two_hop_neighbours)\nfor name, two_hop_neighbour in combined:\n    print(f\"{name} has the following two hop neighbours {two_hop_neighbour}\")\n</code></pre></p> <p>Output</p> <p><pre><code>ATMOSPHERE has the following two hop neighbours ['ATMOSPHERE', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'NEKKE', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'MALI  ', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'VIOLETTE', 'PETOULETTE', 'SELF', 'ATMOSPHERE', 'FEYA', 'MALI', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'LOME', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'ARIELLE', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'BOBO', 'MUSE', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'PETOULETTE', 'EXTERNE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE']\nFEYA has the following two hop neighbours ['FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'NEKKE', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'MALI  ', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'VIOLETTE', 'PETOULETTE', 'SELF', 'ATMOSPHERE', 'FEYA', 'MALI', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'ARIELLE', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'BOBO', 'MUSE', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'PETOULETTE', 'EXTERNE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE']\nMALI has the following two hop neighbours ['FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'NEKKE', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'MALI  ', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'VIOLETTE', 'PETOULETTE', 'SELF', 'ATMOSPHERE', 'FEYA', 'MALI', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'ARIELLE', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'BOBO', 'MUSE', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'PETOULETTE', 'EXTERNE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE']\nANGELE has the following two hop neighbours ['FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'VIOLETTE', 'PETOULETTE', 'SELF', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'ARIELLE', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'BOBO', 'MUSE', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'PETOULETTE', 'EXTERNE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'ANGELE']\nEWINE has the following two hop neighbours ['FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'NEKKE', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'MALI  ', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'VIOLETTE', 'PETOULETTE', 'SELF', 'ATMOSPHERE', 'FEYA', 'MALI', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'ARIELLE', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'BOBO', 'MUSE', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'PETOULETTE', 'EXTERNE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE']\nLIPS has the following two hop neighbours ['FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'NEKKE', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'MALI  ', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'VIOLETTE', 'PETOULETTE', 'SELF', 'ATMOSPHERE', 'FEYA', 'MALI', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'LOME', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'ARIELLE', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'BOBO', 'MUSE', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'PETOULETTE', 'EXTERNE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE']\nFANA has the following two hop neighbours ['FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'NEKKE', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'MALI  ', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'VIOLETTE', 'PETOULETTE', 'SELF', 'ATMOSPHERE', 'FEYA', 'MALI', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'LOME', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'ARIELLE', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'BOBO', 'MUSE', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'PETOULETTE', 'EXTERNE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE']\nFELIPE has the following two hop neighbours ['FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'NEKKE', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'MALI  ', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'LOME', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'ARIELLE', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'BOBO', 'MUSE', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'PETOULETTE', 'EXTERNE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'FELIPE']\nHARLEM has the following two hop neighbours ['FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'VIOLETTE', 'PETOULETTE', 'SELF', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'LOME', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'ARIELLE', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'BOBO', 'MUSE', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'PETOULETTE', 'EXTERNE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE']\nNEKKE has the following two hop neighbours ['FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'NEKKE', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'MALI  ', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'VIOLETTE', 'PETOULETTE', 'SELF', 'ATMOSPHERE', 'FEYA', 'MALI', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'LOME', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'ARIELLE', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'BOBO', 'MUSE', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'PETOULETTE', 'EXTERNE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE']\nPIPO has the following two hop neighbours ['FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'VIOLETTE', 'PETOULETTE', 'SELF', 'ATMOSPHERE', 'FEYA', 'MALI', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'ARIELLE', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'BOBO', 'MUSE', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'PETOULETTE', 'EXTERNE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE']\nLOME has the following two hop neighbours ['FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'NEKKE', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'MALI  ', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'VIOLETTE', 'PETOULETTE', 'SELF', 'ATMOSPHERE', 'FEYA', 'MALI', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'LOME', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'ARIELLE', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'BOBO', 'MUSE', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'PETOULETTE', 'EXTERNE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE']\nMAKO has the following two hop neighbours ['FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'NEKKE', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'MALI  ', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'VIOLETTE', 'PETOULETTE', 'SELF', 'ATMOSPHERE', 'FEYA', 'MALI', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'ARIELLE', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'PETOULETTE', 'EXTERNE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE']\nBOBO has the following two hop neighbours ['FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'NEKKE', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'MALI  ', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'VIOLETTE', 'PETOULETTE', 'SELF', 'ATMOSPHERE', 'FEYA', 'MALI', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'LOME', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'ARIELLE', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'BOBO', 'MUSE', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'PETOULETTE', 'EXTERNE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE']\nMUSE has the following two hop neighbours ['FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'NEKKE', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'MALI  ', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'VIOLETTE', 'PETOULETTE', 'SELF', 'ATMOSPHERE', 'FEYA', 'MALI', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'LOME', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'BOBO', 'MUSE', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'PETOULETTE', 'EXTERNE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE']\nARIELLE has the following two hop neighbours ['FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'NEKKE', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'MALI  ', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'VIOLETTE', 'PETOULETTE', 'SELF', 'ATMOSPHERE', 'FEYA', 'MALI', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'LOME', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'ARIELLE', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'PETOULETTE', 'EXTERNE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE']\nKALI has the following two hop neighbours ['FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'NEKKE', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'MALI  ', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'LOME', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'PETOULETTE', 'EXTERNE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE']\nVIOLETTE has the following two hop neighbours ['FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'NEKKE', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'MALI  ', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'VIOLETTE', 'PETOULETTE', 'SELF', 'ATMOSPHERE', 'FEYA', 'MALI', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'LOME', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'ARIELLE', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'BOBO', 'MUSE', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'VIOLETTE']\nPETOULETTE has the following two hop neighbours ['FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'NEKKE', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'MALI  ', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'VIOLETTE', 'PETOULETTE', 'SELF', 'ATMOSPHERE', 'FEYA', 'MALI', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'LOME', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'ARIELLE', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'BOBO', 'MUSE', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'PETOULETTE', 'EXTERNE']\nSELF has the following two hop neighbours ['ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'VIOLETTE', 'PETOULETTE', 'SELF']\nEXTERNE has the following two hop neighbours ['ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'PETOULETTE', 'EXTERNE']\nMALI   has the following two hop neighbours ['ATMOSPHERE', 'FEYA', 'MALI', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'NEKKE', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'MALI  ']\n</code></pre> </p>"},{"location":"user-guide/querying/6_chaining/#chains-with-properties","title":"Chains with properties","text":"<p>To demonstrate some more complex questions that you could ask our monkey graph, we can include some property aggregation into our chains. </p> <p>In the code below we sum the <code>Weight</code> value of each of <code>Felipe's</code> out-neighbours to rank them by the number of positive interactions he has initiated with them. Following this find the most annoying monkey by ranking globally who on average has had the most negative interactions initiated against them.</p>  Python <p> <code>Edges</code> <pre><code>v = g.node(\"FELIPE\")\nneighbours_weighted = list(\n    zip(\n        v.out_edges.dst.name,\n        v.out_edges.properties.temporal.get(\"Weight\").values().sum(),\n    )\n)\nsorted_weights = sorted(neighbours_weighted, key=lambda v: v[1], reverse=True)\nprint(f\"Felipe's favourite baboons in descending order are {sorted_weights}\")\n\nannoying_monkeys = list(\n    zip(\n        g.nodes.name,\n        g.nodes.in_edges.properties.temporal.get(\"Weight\")\n        .values()\n        .sum()  # sum the weights within each edge\n        .mean()  # average the summed weights for each monkey\n        .collect(),\n    )\n)\nmost_annoying = sorted(annoying_monkeys, key=lambda v: v[1])[0]\nprint(\n    f\"{most_annoying[0]} is the most annoying monkey with an average score of {most_annoying[1]}\"\n)\n</code></pre></p> <p>Output</p> <p><pre><code>Felipe's favourite baboons in descending order are [('NEKKE', 41), ('ANGELE', 31), ('MAKO', 26), ('LOME', 23), ('LIPS', 11), ('HARLEM', 10), ('FANA', 8), ('MALI', 6), ('FEYA', 5), ('EWINE', 5), ('ARIELLE', 5), ('PIPO', 3), ('SELF', 2), ('ATMOSPHERE', 1), ('BOBO', 1), ('VIOLETTE', 1), ('PETOULETTE', 1), ('MUSE', -1)]\nEXTERNE is the most annoying monkey with an average score of -2.0\n</code></pre> </p>"},{"location":"user-guide/views/1_intro/","title":"Introduction and dataset","text":"<p>All of the operations we have discussed up until this point have been executed on the whole graph, including the full history. In this section we will look at applying <code>Graph Views</code> which provide a way to look at a subset of this data without having to reingest it. </p> <p>Raphtory can maintain hundreds of thousands of <code>Graph Views</code> in parallel, allows chaining view functions together to create as specific a filter as is required for your use case, and provides a unified API such that all functions mentioned can be called on a graph, node or edge.</p> <p>Info</p> <p>For this chapter we shall continue using the Monkey graph described in the Querying Introduction.</p>"},{"location":"user-guide/views/2_time/","title":"Querying the graph over time","text":"<p>The first set of view functions we will look at are for traveling through time, viewing the graph as it was at a specific point, or between two points (applying a time window). For this Raphtory provides six functions: <code>before()</code>, <code>at()</code>, <code>after()</code>, <code>window()</code>, <code>expand()</code> and <code>rolling()</code>.</p> <p>All of these functions can be called on a graph, node, or edge, returning an equivalent <code>Graph View</code>, <code>Node View</code> or <code>Edge View</code> which have all the same functions as its unfiltered counterpart. This means if you write a function which takes a Raphtory entity, it will work irrelevant of which filters have been applied.</p>"},{"location":"user-guide/views/2_time/#before-at-and-after","title":"Before, At and After","text":"<p>Beginning with the simplest of these filters, <code>before()</code>, <code>at()</code> and <code>after()</code> take a singular <code>time</code> argument in epoch (integer) or datetime (string/datetime object) format and return a <code>View</code> of the object which includes:</p> <ul> <li><code>before()</code> - All updates between the beginning of the graph's history and the provided time (exclusive of the time provided).</li> <li><code>after()</code> - All updates between the provided time and the end of the graph's history (exclusive of the time provided)</li> <li><code>at()</code>- Only updates which happened at exactly the time provided.</li> </ul> <p>Note</p> <p>While the first two are more useful on continuous time datasets, <code>at()</code> can be very handy when you have snapshots or logical timestamps and want to look at them individually or compare/contrast.</p> <p>As an example of these, in the code below where we print the degree of <code>Lome</code> on the full dataset, before 12:17 on the 13th of June and after 9:07 on the 30th of June.</p> <p>We also introduce two new time functions here, <code>start()</code> and <code>end()</code>, which specify the time range a view is filtered to, if one has been applied. </p>  Python <pre><code>v = g.node(\"LOME\")\n\nprint(f\"Across the full dataset {v.name} interacted with {v.degree()} other monkeys.\")\n\nv_before = g.before(1560428239000).node(\"LOME\")  # 13/06/2019 12:17:19 as epoch\nprint(\n    f\"Between {v_before.start_date_time} and {v_before.end_date_time}, {v_before.name} interacted with {v_before.degree()} other monkeys.\"\n)\n\nv_after = g.node(\"LOME\").after(\"2019-06-30 9:07:31\")\nprint(\n    f\"Between {v_after.start_date_time} and {v_after.end_date_time}, {v_after.name} interacted with {v_after.degree()} other monkeys.\"\n)\n</code></pre> <p>Output</p> <p><pre><code>Across the full dataset LOME interacted with 18 other monkeys.\nBetween None and 2019-06-13 12:17:19+00:00, LOME interacted with 5 other monkeys.\nBetween 2019-06-30 09:07:31.001000+00:00 and None, LOME interacted with 17 other monkeys.\n</code></pre> </p> <p>Note</p> <p>You may have noticed in the code we have called the <code>before()</code> on the graph and <code>after()</code> on the node. This is important, as there are some subtle differences in where these functions are called, which we shall discuss below.</p>"},{"location":"user-guide/views/2_time/#window","title":"Window","text":"<p>The <code>window()</code> function is a more general version of the functions above, allowing you to set both a <code>start</code> time as well as an <code>end</code> time (inclusive of start, exclusive of end). </p> <p>This is useful for digging into specific ranges of the history that you are interested in, for example a given day within your data, filtering everything else outside this range. An example of this can be seen below where we look at the number of times <code>Lome</code> interacts wth <code>Nekke</code> within the full dataset and for one day between the 13th of June and the 14th of June.</p> <p>Info</p> <p>We use datetime objects in this example, but it would work exactly the same with string dates and epoch integers.</p>  Python <pre><code>from datetime import datetime\n\nstart_day = datetime.strptime(\"2019-06-13\", \"%Y-%m-%d\")\nend_day = datetime.strptime(\"2019-06-14\", \"%Y-%m-%d\")\ne = g.edge(\"LOME\", \"NEKKE\")\nprint(\n    f\"Across the full dataset {e.src.name} interacted with {e.dst.name} {len(e.history())} times\"\n)\ne = e.window(start_day, end_day)\nprint(\n    f\"Between {e.start_date_time} and {e.end_date_time}, {e.src.name} interacted with {e.dst.name} {len(e.history())} times\"\n)\nprint(\n    f\"Window start: {e.start_date_time}, First update: {e.earliest_date_time}, Last update: {e.latest_date_time}, Window End: {e.end_date_time}\"\n)\n</code></pre> <p>Output</p> <p><pre><code>Across the full dataset LOME interacted with NEKKE 41 times\nBetween 2019-06-13 00:00:00+00:00 and 2019-06-14 00:00:00+00:00, LOME interacted with NEKKE 8 times\nWindow start: 2019-06-13 00:00:00+00:00, First update: 2019-06-13 10:18:00+00:00, Last update: 2019-06-13 15:05:00+00:00, Window End: 2019-06-14 00:00:00+00:00\n</code></pre> </p>"},{"location":"user-guide/views/2_time/#traversing-the-graph-with-views","title":"Traversing the graph with views","text":"<p>As mentioned above, there are some slight differences when applying views, depending on which object you call them on. This has to do with how the filters propagate as you traverse the graph.</p> <p>As a general rule, when you call any function on a <code>Graph View</code>, <code>Node View</code> or <code>Edge View</code> which returns another entity, the view's filters will be passed onto the entities it returns. For example, if you call <code>before()</code> on a graph and then call <code>node()</code>, this will return a <code>Node View</code> filtered to the time passed to the graph.</p> <p>However, if this was always the case, it would make it very annoying if we later wanted to explore outside of these bounds, especially as we traverse across the graph. </p> <p>To allow for both global bounds and moving bounds, if a filter is applied onto the graph, all entities extracted always have this filter applied. However, if it is applied to either a node or an edge, once you have traversed to a new node (neighbour) this filter is removed. </p> <p>As an example of this, below we look at LOME's one hop neighbours before the 20th of June and their neighbours (LOME's two hop neighbours) after the 25th of June. First we try calling <code>before()</code> on the graph, which works for the one hop neighbours, but once the <code>after()</code> has been applied, the graph is empty as their is no overlap in dates between the two filters. </p> <p>Next, we instead call <code>before()</code> on the node, which once the neighbours have been reached allows the <code>after()</code> to work as desired as the original filter has been removed.</p>  Python <pre><code>first_day = datetime.strptime(\"2019-06-20\", \"%Y-%m-%d\")\nsecond_day = datetime.strptime(\"2019-06-25\", \"%Y-%m-%d\")\n\none_hop_neighbours = g.before(first_day).node(\"LOME\").neighbours.name.collect()\ntwo_hop_neighbours = (\n    g.before(first_day).node(\"LOME\").neighbours.after(second_day).neighbours.collect()\n)\nprint(\n    f\"When the before is applied to the graph, LOME's one hop neighbours are: {one_hop_neighbours}\"\n)\nprint(\n    f\"When the before is applied to the graph, LOME's two hop neighbours are: {two_hop_neighbours}\"\n)\none_hop_neighbours = g.node(\"LOME\").before(first_day).neighbours.name.collect()\ntwo_hop_neighbours = (\n    g.node(\"LOME\")\n    .before(first_day)\n    .neighbours.after(second_day)\n    .neighbours.name.collect()\n)\nprint(\n    f\"When the before is applied to the node, LOME's one hop neighbours are: {one_hop_neighbours}\"\n)\nprint(\n    f\"When the before is applied to the node, LOME's two hop neighbours are: {two_hop_neighbours}\"\n)\n</code></pre> <p>Output</p> <p><pre><code>When the before is applied to the graph, LOME's one hop neighbours are: ['ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'MAKO', 'BOBO', 'MUSE', 'VIOLETTE']\nWhen the before is applied to the graph, LOME's two hop neighbours are: []\nWhen the before is applied to the node, LOME's one hop neighbours are: ['ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'MAKO', 'BOBO', 'MUSE', 'VIOLETTE']\nWhen the before is applied to the node, LOME's two hop neighbours are: ['FEYA', 'ANGELE', 'EWINE', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'ATMOSPHERE', 'MALI', 'ANGELE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'VIOLETTE', 'PETOULETTE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'NEKKE', 'LOME', 'MAKO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'MALI  ', 'ATMOSPHERE', 'MALI', 'ANGELE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'VIOLETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'MUSE', 'ARIELLE', 'KALI', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'FELIPE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'ARIELLE', 'VIOLETTE', 'PETOULETTE', 'ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'KALI', 'PETOULETTE', 'EXTERNE']\n</code></pre> </p>"},{"location":"user-guide/views/2_time/#expanding","title":"Expanding","text":"<p>If you have data covering a large period of time, or have many time points of interest, it is quite likely you will find yourself calling the above functions over and over. If there is a pattern to these calls, say you are interested in how your graph looks every morning for the last week, you can instead utilise <code>expanding()</code>. </p> <p><code>expanding()</code> will return an iterable of views as if you called <code>before()</code> from the earliest time to the latest time at increments of a given <code>step</code>. </p> <p>The step can be given as a simple epoch integer, or a natural language string describing the interval. For the latter, this is converted into a iterator of datetimes, handling all corner cases like varying month length and leap years.</p> <p>Within the string you can reference <code>years</code>, <code>months</code> <code>weeks</code>, <code>days</code>, <code>hours</code>, <code>minutes</code>, <code>seconds</code> and <code>milliseconds</code>. These can be singular or plural and the string can include 'and', spaces, and commas to improve readability. </p> <p>In the code below, we can see some examples of this where we first increment through the full history of the graph a week at a time. This creates four views, each of which we ask how many monkey interactions it has seen. You will notice the start time doesn't not change, but the end time increments by 7 days each view.</p> <p>The second example shows the complexity of increments Raphtory can handle, stepping by <code>2 days, 3 hours, 12 minutes and 6 seconds</code> each time. We have additionally bounded this expand via a window between the 13th and 23rd of June to demonstrate how these views may be chained.</p>  Python <pre><code>print(\n    f\"The full range of time in the graph is {g.earliest_date_time} to {g.latest_date_time}\\n\"\n)\n\nfor expanding_g in g.expanding(\"1 week\"):\n    print(\n        f\"From {expanding_g.start_date_time} to {expanding_g.end_date_time} there were {expanding_g.count_temporal_edges()} monkey interactions\"\n    )\n\nprint()\nstart_day = datetime.strptime(\"2019-06-13\", \"%Y-%m-%d\")\nend_day = datetime.strptime(\"2019-06-23\", \"%Y-%m-%d\")\nfor expanding_g in g.window(start_day, end_day).expanding(\n    \"2 days, 3 hours, 12 minutes and 6 seconds\"\n):\n    print(\n        f\"From {expanding_g.start_date_time} to {expanding_g.end_date_time} there were {expanding_g.count_temporal_edges()} monkey interactions\"\n    )\n</code></pre> <p>Output</p> <p><pre><code>The full range of time in the graph is 2019-06-13 09:50:00+00:00 to 2019-07-10 11:05:00+00:00\n\nFrom None to 2019-06-20 09:50:00+00:00 there were 789 monkey interactions\nFrom None to 2019-06-27 09:50:00+00:00 there were 1724 monkey interactions\nFrom None to 2019-07-04 09:50:00+00:00 there were 2358 monkey interactions\nFrom None to 2019-07-11 09:50:00+00:00 there were 3196 monkey interactions\n\nFrom 2019-06-13 00:00:00+00:00 to 2019-06-15 03:12:06+00:00 there were 377 monkey interactions\nFrom 2019-06-13 00:00:00+00:00 to 2019-06-17 06:24:12+00:00 there were 377 monkey interactions\nFrom 2019-06-13 00:00:00+00:00 to 2019-06-19 09:36:18+00:00 there were 691 monkey interactions\nFrom 2019-06-13 00:00:00+00:00 to 2019-06-21 12:48:24+00:00 there were 1143 monkey interactions\nFrom 2019-06-13 00:00:00+00:00 to 2019-06-23 00:00:00+00:00 there were 1164 monkey interactions\n</code></pre> </p>"},{"location":"user-guide/views/2_time/#rolling","title":"Rolling","text":"<p>If instead of including all prior history, you want a rolling window, you may use <code>rolling()</code>. This function will return an iterable of views, incrementing by a <code>window</code> size and only including the history from inside the window period (Inclusive of start, exclusive of end). This allows you to easily extract daily or monthly metrics.</p> <p>For example, below we take the code from expanding and swap out the function for <code>rolling()</code>. In the first loop we can see both the start date and end date increase by seven days each time, and the number of monkey interactions sometimes decreases as older data is dropped from the window.</p>  Python <pre><code>print(\"Rolling 1 week\")\nfor rolling_g in g.rolling(window=\"1 week\"):\n    print(\n        f\"From {rolling_g.start_date_time} to {rolling_g.end_date_time} there were {rolling_g.count_temporal_edges()} monkey interactions\"\n    )\n</code></pre> <p>Output</p> <p><pre><code>Rolling 1 week\nFrom 2019-06-13 09:50:00+00:00 to 2019-06-20 09:50:00+00:00 there were 789 monkey interactions\nFrom 2019-06-20 09:50:00+00:00 to 2019-06-27 09:50:00+00:00 there were 935 monkey interactions\nFrom 2019-06-27 09:50:00+00:00 to 2019-07-04 09:50:00+00:00 there were 634 monkey interactions\nFrom 2019-07-04 09:50:00+00:00 to 2019-07-11 09:50:00+00:00 there were 838 monkey interactions\n</code></pre> </p> <p>Alongside the window size, <code>rolling()</code> takes an option <code>step</code> argument which specifies how far along the timeline it should increment before applying the next window. By default this is the same as <code>window</code>, allowing all updates to be analysed exactly once in non-overlapping windows. </p> <p>If, however, you would like to have overlapping or fully disconnected windows, you can set a <code>step</code> smaller or greater than the given <code>window</code> size. </p> <p>As a small example of how useful this can be, in the following segment we plot the daily unique interactions of <code>Lome</code> via <code>matplotlib</code> in only 10 lines! </p> <p>Info</p> <p>We have to recreate the graph in the first section of this code block so that the output can be rendered as part of the documentation. Please ignore this. </p>  Python <pre><code># mkdocs: render\n###RECREATION OF THE GRAPH SO IT CAN BE RENDERED\nimport matplotlib.pyplot as plt\nimport pandas as pd\nfrom raphtory import Graph\n\nedges_df = pd.read_csv(\n    \"data/OBS_data.txt\", sep=\"\\t\", header=0, usecols=[0, 1, 2, 3, 4], parse_dates=[0]\n)\nedges_df[\"DateTime\"] = pd.to_datetime(edges_df[\"DateTime\"])\nedges_df.dropna(axis=0, inplace=True)\nedges_df[\"Weight\"] = edges_df[\"Category\"].apply(\n    lambda c: 1 if (c == \"Affiliative\") else (-1 if (c == \"Agonistic\") else 0)\n)\n\ng = Graph()\ng.load_edges_from_pandas(\n    df=edges_df,\n    time=\"DateTime\",\n    src=\"Actor\",\n    dst=\"Recipient\",\n    layer_col=\"Behavior\",\n    properties=[\"Weight\"],\n)\n\n###ACTUAL IMPORT CODE\nimportance = []\ntime = []\nfor rolling_lome in g.node(\"LOME\").rolling(\"1 day\"):\n    importance.append(rolling_lome.degree())\n    time.append(rolling_lome.end_date_time)\n\nplt.plot(time, importance, marker=\"o\")\nplt.xlabel(\"Date\")\nplt.xticks(rotation=45)\nplt.ylabel(\"Daily Unique Interactions\")\nplt.title(\"Lome's daily interaction count\")\nplt.grid(True)\n</code></pre>"},{"location":"user-guide/views/3_layer/","title":"Layered graphs","text":"<p>Info</p> <p>Edge layers have been discussed several times, notably in Ingestion and Exploded Edges. Please check these before reading this section.</p> <p>As previously discussed, an edge object by default will contain information on all layers between its source and destination nodes. However, it is often the case that there are a subset of these relationships that we are interested in. To handle this the <code>Graph</code>, <code>Node</code> and <code>Edge</code> provide the <code>layers()</code> function. This takes a list of layer names and returns a view with only edge updates that occurred on these layers. </p> <p>Layer views can also be used in combination with any other view function. As an example of this, in the code below we look at the total edge weight over the full graph, then restrict this to the <code>Grooming</code> and <code>Resting</code> layers and then reduce this further by applying a window between the 13th and 20th of June.</p>  Python <pre><code>total_weight = g.edges.properties.temporal.get(\"Weight\").values().sum().sum()\nprint(f\"Total weight across all edges is {total_weight}.\")\n\ntotal_weight = (\n    g.layers([\"Grooming\", \"Resting\"])\n    .edges.properties.temporal.get(\"Weight\")\n    .values()\n    .sum()\n    .sum()\n)\nprint(f\"Total weight across Grooming and Resting is {total_weight}.\")\n\nstart_day = datetime.strptime(\"2019-06-13\", \"%Y-%m-%d\")\nend_day = datetime.strptime(\"2019-06-20\", \"%Y-%m-%d\")\ntotal_weight = (\n    g.layers([\"Grooming\", \"Resting\"])\n    .window(start_day, end_day)\n    .edges.properties.temporal.get(\"Weight\")\n    .values()\n    .sum()\n    .sum()\n)\nprint(\n    f\"Total weight across Grooming and Resting between {start_day} and {end_day} is {total_weight}.\"\n)\n</code></pre> <p>Output</p> <p><pre><code>Total weight across all edges is 2948.\nTotal weight across Grooming and Resting is 1685.\nTotal weight across Grooming and Resting between 2019-06-13 00:00:00 and 2019-06-20 00:00:00 is 403.\n</code></pre> </p>"},{"location":"user-guide/views/3_layer/#traversing-the-graph-with-layers","title":"Traversing the graph with layers","text":"<p>As with the time based filters (discussed here), if a layer view is applied to the graph, all extracted entities will have this view applied to them. If, however, the layer view is applied to a node or edge, it will only last until you have hoped to a new node.</p> <p>Expanding on the example from the time views, if we wanted to look at LOME's neighbours who he has groomed, followed by who those monkeys have rested with, we could write the following query.</p>  Python <pre><code>two_hop_neighbours = set(\n    g.node(\"LOME\")\n    .layer(\"Grooming\")\n    .neighbours.layer(\"Resting\")\n    .neighbours.name.collect()\n)\nprint(\n    f\"When the Grooming layer is applied to the node, LOME's two hop neighbours are: {two_hop_neighbours}\"\n)\n</code></pre> <p>Output</p> <p><pre><code>When the Grooming layer is applied to the node, LOME's two hop neighbours are: {'ATMOSPHERE', 'FANA', 'VIOLETTE', 'FEYA', 'PIPO', 'ANGELE', 'NEKKE', 'MAKO', 'BOBO', 'ARIELLE', 'PETOULETTE', 'EWINE', 'HARLEM', 'MALI', 'LOME', 'LIPS', 'KALI', 'MUSE', 'FELIPE'}\n</code></pre> </p>"},{"location":"user-guide/views/4_subgraph/","title":"Subgraph","text":"<p>Similar to only being interested in a subset of edge layers, for some use cases we may only be interested in a subset of nodes within the graph. One solution to this could be to call <code>g.nodes</code> and filtering this before continuing your workflow. However, this does not remove anything for later calls to <code>neighbours</code>, <code>edges</code>, etc. Meaning you will have to constantly recheck these lists. </p> <p>To handle all of these corner cases Raphtory provides the <code>subgraph()</code> function which takes a list of nodes of interest. This applies a view such that all nodes not in the list are hidden from all future function calls. This also hides any edges linked to hidden nodes to keep the subgraph consistent. </p> <p>In the below example we demonstrate this by looking at the neighbours of <code>FELIPE</code> in the full graph, vs a subgraph of <code>FELIPE</code>, <code>LIPS</code>, <code>NEKKE</code>, <code>LOME</code> and <code>BOBO</code>. We also show how that <code>subgraph()</code> can be combined with other view functions, in this case a window between the 17th and 18th of June.</p>  Python <pre><code>temp = g.count_nodes()\nprint(f\"There are {temp} monkeys in the whole graph\")\n\nsubgraph = g.subgraph([\"FELIPE\", \"LIPS\", \"NEKKE\", \"LOME\", \"BOBO\"])\nprint(f\"There are {subgraph.count_nodes()} monkeys in the subgraph\")\nneighbours = g.node(\"FELIPE\").neighbours.name.collect()\nprint(f\"FELIPE has the following neighbours in the full graph: {neighbours}\")\nneighbours = subgraph.node(\"FELIPE\").neighbours.name.collect()\nprint(f\"FELIPE has the following neighbours in the subgraph: {neighbours}\")\nstart_day = datetime.strptime(\"2019-06-17\", \"%Y-%m-%d\")\nend_day = datetime.strptime(\"2019-06-18\", \"%Y-%m-%d\")\nneighbours = (\n    subgraph.node(\"FELIPE\").window(start_day, end_day).neighbours.name.collect()\n)\nprint(\n    f\"FELIPE has the following neighbours in the subgraph between {start_day} and {end_day}: {neighbours}\"\n)\n</code></pre> <p>Output</p> <p><pre><code>There are 22 monkeys in the whole graph\nThere are 5 monkeys in the subgraph\nFELIPE has the following neighbours in the full graph: ['ATMOSPHERE', 'FEYA', 'MALI', 'ANGELE', 'EWINE', 'LIPS', 'FANA', 'HARLEM', 'NEKKE', 'PIPO', 'LOME', 'MAKO', 'BOBO', 'MUSE', 'ARIELLE', 'VIOLETTE', 'PETOULETTE', 'SELF']\nFELIPE has the following neighbours in the subgraph: ['LIPS', 'NEKKE', 'LOME', 'BOBO']\nFELIPE has the following neighbours in the subgraph between 2019-06-17 00:00:00 and 2019-06-18 00:00:00: ['NEKKE']\n</code></pre> </p>"},{"location":"user-guide/views/5_materialize/","title":"Materialize","text":"<p>All of the view functions mentioned hold zero updates of their own, simply providing a lens through which to look at the original graph you ingested into. This is by design so that we can have many of them without our machines exploding from data duplication. </p> <p>This does mean, however, if the original graph is updated, all of the views over it will also update. If you do not want this to happen you may <code>materialize()</code> a view, creating a new graph and copying all the updates the view contains into it. </p> <p>Below we can see an example of this where we create a windowed view between the 17th and 18th of June and then materialize this. After adding a new monkey interaction in the materialized graph, we can see the original graph doesn't contains this update, but our materialized graph does.</p>  Python <pre><code>start_time = datetime.strptime(\"2019-06-17\", \"%Y-%m-%d\")\nend_time = datetime.strptime(\"2019-06-18\", \"%Y-%m-%d\")\nwindowed_view = g.window(start_time, end_time)\n\nmaterialized_graph = windowed_view.materialize()\nprint(\n    f\"Before the update the view had {windowed_view.count_temporal_edges()} edge updates\"\n)\nprint(\n    f\"Before the update the materialized graph had {materialized_graph.count_temporal_edges()} edge updates\"\n)\nprint(\"Adding new update to materialized_graph\")\nmaterialized_graph.add_edge(1, \"FELIPE\", \"LOME\", properties={\"Weight\": 1}, layer=\"Grooming\")\nprint(\n    f\"After the update the view had {windowed_view.count_temporal_edges()} edge updates\"\n)\nprint(\n    f\"After the update the materialized graph had {materialized_graph.count_temporal_edges()} edge updates\"\n)\n</code></pre> <p>Output</p> <p><pre><code>Before the update the view had 132 edge updates\nBefore the update the materialized graph had 132 edge updates\nAdding new update to materialized_graph\nAfter the update the view had 132 edge updates\nAfter the update the materialized graph had 133 edge updates\n</code></pre> </p>"}]}